<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{DECK_NAME}} - Slide Viewer</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --amp-black: #0a0a0a;
            --amp-dark-alt: #1a1a1a;
            --amp-mid-gray: #2a2a2a;
            --amp-light-gray: #888888;
            --amp-lime: #d4e94c;
            --amp-teal: #4ecdc4;
            --amp-white: #ffffff;
            --font-heading: 'Outfit', system-ui, sans-serif;
            --font-body: 'Outfit', system-ui, sans-serif;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-body);
            background: var(--amp-black);
            min-height: 100vh;
            color: var(--amp-white);
        }

        /* ═══════════════════════════════════════════════════════════════════════ */
        /* GALLERY VIEW                                                             */
        /* ═══════════════════════════════════════════════════════════════════════ */
        #gallery-view {
            padding: 60px;
        }

        #gallery-view.hidden {
            display: none;
        }

        .header {
            text-align: center;
            margin-bottom: 60px;
            padding-bottom: 40px;
            border-bottom: 1px solid var(--amp-mid-gray);
            position: relative;
        }

        .header::after {
            content: '';
            position: absolute;
            bottom: -1px;
            left: 50%;
            transform: translateX(-50%);
            width: 120px;
            height: 2px;
            background: var(--amp-lime);
        }

        .deck-badge {
            display: inline-block;
            font-family: var(--font-body);
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: var(--amp-lime);
            background: rgba(212, 233, 76, 0.1);
            padding: 6px 16px;
            margin-bottom: 16px;
        }

        .title {
            font-family: var(--font-heading);
            font-size: 36px;
            font-weight: 400;
            color: var(--amp-white);
            margin-bottom: 12px;
        }

        .subtitle {
            font-family: var(--font-body);
            font-size: 16px;
            color: var(--amp-light-gray);
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 32px;
            max-width: 1600px;
            margin: 0 auto;
        }

        .card {
            background: var(--amp-dark-alt);
            border: 1px solid var(--amp-mid-gray);
            overflow: hidden;
            transition: transform 0.3s ease, border-color 0.3s ease;
            cursor: pointer;
        }

        .card:hover {
            transform: translateY(-4px);
            border-color: var(--amp-lime);
        }

        .card-preview {
            width: 100%;
            aspect-ratio: 16/9;
            background: var(--amp-black);
            overflow: hidden;
            position: relative;
        }

        .card-preview iframe {
            width: 480%;
            height: 480%;
            border: none;
            pointer-events: none;
            transform: scale(0.208);
            transform-origin: top left;
        }

        .card-info {
            padding: 24px;
            border-top: 1px solid var(--amp-mid-gray);
        }

        .card-number {
            font-family: var(--font-body);
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: var(--amp-lime);
            margin-bottom: 8px;
        }

        .card-title {
            font-family: var(--font-heading);
            font-size: 18px;
            font-weight: 400;
            color: var(--amp-white);
        }

        /* ═══════════════════════════════════════════════════════════════════════ */
        /* PRESENTATION VIEW                                                        */
        /* ═══════════════════════════════════════════════════════════════════════ */
        #presentation-view {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: var(--amp-black);
            z-index: 1000;
            display: flex;
            flex-direction: column;
        }

        #presentation-view.hidden {
            display: none;
        }

        .presentation-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 24px;
            background: var(--amp-dark-alt);
            border-bottom: 1px solid var(--amp-mid-gray);
        }

        .presentation-title {
            font-family: var(--font-heading);
            font-size: 18px;
            font-weight: 400;
            color: var(--amp-white);
        }

        .presentation-controls {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .slide-counter {
            font-family: var(--font-body);
            font-size: 14px;
            color: var(--amp-light-gray);
            min-width: 80px;
            text-align: center;
        }

        .nav-btn {
            background: transparent;
            border: 1px solid var(--amp-mid-gray);
            color: var(--amp-white);
            padding: 8px 16px;
            font-family: var(--font-body);
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .nav-btn:hover:not(:disabled) {
            border-color: var(--amp-lime);
            color: var(--amp-lime);
        }

        .nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .close-btn {
            background: transparent;
            border: 1px solid var(--amp-mid-gray);
            color: var(--amp-white);
            width: 36px;
            height: 36px;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-btn:hover {
            border-color: var(--amp-lime);
            color: var(--amp-lime);
        }

        /* ═══════════════════════════════════════════════════════════════════════ */
        /* DOWNLOAD MENU                                                            */
        /* ═══════════════════════════════════════════════════════════════════════ */
        .download-btn {
            background: transparent;
            border: 1px solid var(--amp-mid-gray);
            color: var(--amp-white);
            width: 36px;
            height: 36px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .download-btn:hover {
            border-color: var(--amp-lime);
            color: var(--amp-lime);
        }

        .download-btn svg {
            width: 18px;
            height: 18px;
        }

        .download-menu {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 8px;
            background: var(--amp-dark-alt);
            border: 1px solid var(--amp-mid-gray);
            min-width: 220px;
            z-index: 1002;
        }

        .download-menu.hidden {
            display: none;
        }

        .download-menu-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            color: var(--amp-white);
            font-family: var(--font-body);
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
            background: transparent;
            width: 100%;
            text-align: left;
        }

        .download-menu-item:hover {
            background: var(--amp-mid-gray);
            color: var(--amp-lime);
        }

        .download-menu-item svg {
            width: 16px;
            height: 16px;
            flex-shrink: 0;
        }

        .download-menu-item span {
            flex: 1;
        }

        .download-wrapper {
            position: relative;
        }

        .presentation-content {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 24px;
            overflow: hidden;
        }

        .slide-container {
            position: relative;
            background: var(--amp-black);
            border: 1px solid var(--amp-mid-gray);
            overflow: hidden;
            /* Dimensions set by JavaScript based on available space */
        }

        .slide-container iframe {
            width: 1920px;
            height: 1080px;
            border: none;
            transform-origin: top left;
            /* Scale set by JavaScript */
        }

        /* Keyboard hint */
        .keyboard-hint {
            position: fixed;
            bottom: 20px;
            left: calc(200px + 50%);
            transform: translateX(-50%);
            font-family: var(--font-body);
            font-size: 12px;
            color: var(--amp-light-gray);
            background: var(--amp-dark-alt);
            padding: 8px 16px;
            border: 1px solid var(--amp-mid-gray);
            opacity: 0.7;
            z-index: 1001;
        }

        .keyboard-hint kbd {
            background: var(--amp-mid-gray);
            padding: 2px 6px;
            margin: 0 4px;
            font-family: var(--font-body);
        }

        /* ═══════════════════════════════════════════════════════════════════════ */
        /* ANIMATION BUILDER                                                         */
        /* ═══════════════════════════════════════════════════════════════════════ */
        .build-btn {
            background: transparent;
            border: 1px solid var(--amp-mid-gray);
            color: var(--amp-white);
            width: 36px;
            height: 36px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .build-btn:hover {
            border-color: var(--amp-lime);
            color: var(--amp-lime);
        }

        .build-btn.active {
            border-color: var(--amp-lime);
            color: var(--amp-lime);
            background: rgba(212, 233, 76, 0.1);
        }

        .build-btn svg {
            width: 18px;
            height: 18px;
        }

        .animation-builder-panel {
            position: fixed;
            left: 0;
            top: 57px;
            width: 200px;
            height: calc(100vh - 57px);
            background: var(--amp-dark-alt);
            border-right: 1px solid var(--amp-mid-gray);
            overflow-y: auto;
            padding: 16px;
            z-index: 1001;
            display: flex;
            flex-direction: column;
        }

        .animation-builder-panel.hidden {
            display: none;
        }

        .animation-builder-panel::-webkit-scrollbar {
            width: 6px;
        }

        .animation-builder-panel::-webkit-scrollbar-track {
            background: var(--amp-dark-alt);
        }

        .animation-builder-panel::-webkit-scrollbar-thumb {
            background: var(--amp-mid-gray);
        }

        .animation-builder-panel::-webkit-scrollbar-thumb:hover {
            background: var(--amp-light-gray);
        }

        .builder-header {
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--amp-mid-gray);
        }

        .builder-title {
            font-family: var(--font-heading);
            font-size: 14px;
            font-weight: 600;
            color: var(--amp-white);
            margin: 0 0 8px 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .builder-done-btn {
            background: transparent;
            border: 1px solid var(--amp-mid-gray);
            color: var(--amp-white);
            font-family: var(--font-body);
            font-size: 11px;
            padding: 4px 10px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .builder-done-btn:hover {
            border-color: var(--amp-lime);
            color: var(--amp-lime);
        }

        .builder-instructions {
            font-family: var(--font-body);
            font-size: 11px;
            color: var(--amp-light-gray);
            line-height: 1.5;
        }

        .builder-selection-count {
            font-family: var(--font-body);
            font-size: 12px;
            color: var(--amp-lime);
            margin: 12px 0;
            padding: 8px;
            background: rgba(212, 233, 76, 0.1);
            text-align: center;
        }

        .builder-create-group-btn {
            width: 100%;
            background: transparent;
            border: 1px dashed var(--amp-mid-gray);
            color: var(--amp-white);
            font-family: var(--font-body);
            font-size: 12px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            margin-bottom: 12px;
        }

        .builder-create-group-btn:hover:not(:disabled) {
            border-color: var(--amp-lime);
            color: var(--amp-lime);
        }

        .builder-create-group-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .builder-groups-list {
            flex: 1;
            overflow-y: auto;
        }

        .builder-group {
            margin-bottom: 8px;
            background: var(--amp-black);
            border: 1px solid var(--amp-mid-gray);
            border-left: 3px solid var(--amp-mid-gray);
            padding: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .builder-group:hover {
            background: var(--amp-dark-alt);
        }

        .builder-group.group-color-0 { border-left-color: var(--amp-lime); }
        .builder-group.group-color-1 { border-left-color: var(--amp-teal); }
        .builder-group.group-color-2 { border-left-color: #a78bfa; }
        .builder-group.group-color-3 { border-left-color: #f97316; }
        .builder-group.group-color-4 { border-left-color: #ec4899; }

        /* Selected group states */
        .builder-group.group-selected {
            background: rgba(212, 233, 76, 0.1);
            border-color: var(--amp-lime);
        }
        .builder-group.group-selected.group-color-0 { border-left-color: var(--amp-lime); border-color: var(--amp-lime); }
        .builder-group.group-selected.group-color-1 { border-left-color: var(--amp-teal); border-color: var(--amp-teal); }
        .builder-group.group-selected.group-color-2 { border-left-color: #a78bfa; border-color: #a78bfa; }
        .builder-group.group-selected.group-color-3 { border-left-color: #f97316; border-color: #f97316; }
        .builder-group.group-selected.group-color-4 { border-left-color: #ec4899; border-color: #ec4899; }

        .builder-group-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 6px;
        }

        .builder-group-title {
            font-family: var(--font-body);
            font-size: 11px;
            font-weight: 600;
            color: var(--amp-white);
        }

        .builder-group-count {
            font-family: var(--font-body);
            font-size: 10px;
            color: var(--amp-light-gray);
        }

        .builder-group-controls {
            display: flex;
            gap: 4px;
            margin-top: 8px;
        }

        .group-btn {
            background: transparent;
            border: 1px solid var(--amp-mid-gray);
            color: var(--amp-light-gray);
            padding: 4px 8px;
            font-size: 12px;
            cursor: pointer;
            transition: border-color 0.2s ease, color 0.2s ease;
        }

        .group-btn:hover:not(:disabled) {
            border-color: var(--amp-lime);
            color: var(--amp-lime);
        }

        .group-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .group-delete:hover:not(:disabled) {
            border-color: #ff6b6b;
            color: #ff6b6b;
        }

        .builder-footer {
            margin-top: auto;
            padding-top: 12px;
            border-top: 1px solid var(--amp-mid-gray);
        }

        .builder-footer-note {
            font-family: var(--font-body);
            font-size: 10px;
            color: var(--amp-light-gray);
            line-height: 1.4;
        }

        .builder-export-btn {
            width: 100%;
            margin-top: 12px;
            padding: 8px 12px;
            background: var(--amp-lime);
            color: var(--amp-black);
            border: none;
            font-family: var(--font-body);
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .builder-export-btn:hover {
            background: #e5f75d;
        }

        /* ═══════════════════════════════════════════════════════════════════════ */
        /* BUILD PLAYBACK ANIMATIONS (Fullscreen Only)                              */
        /* ═══════════════════════════════════════════════════════════════════════ */

        /* Elements hidden before their build step */
        [data-build-id].build-hidden {
            opacity: 0 !important;
            visibility: hidden !important;
        }

        /* Fade-in animation when revealed */
        [data-build-id].build-revealing {
            animation: buildFadeIn 0.4s ease-out forwards;
        }

        /* Elements that have been revealed */
        [data-build-id].build-visible {
            opacity: 1;
            visibility: visible;
        }

        @keyframes buildFadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* ═══════════════════════════════════════════════════════════════════════ */
        /* PRESENTATION SIDEBAR                                                     */
        /* ═══════════════════════════════════════════════════════════════════════ */
        .presentation-sidebar {
            position: fixed;
            left: 0;
            top: 57px;
            width: 200px;
            height: calc(100vh - 57px);
            background: var(--amp-dark-alt);
            border-right: 1px solid var(--amp-mid-gray);
            overflow-y: auto;
            padding: 16px;
            z-index: 1001;
        }

        .presentation-sidebar::-webkit-scrollbar {
            width: 6px;
        }

        .presentation-sidebar::-webkit-scrollbar-track {
            background: var(--amp-dark-alt);
        }

        .presentation-sidebar::-webkit-scrollbar-thumb {
            background: var(--amp-mid-gray);
        }

        .presentation-sidebar::-webkit-scrollbar-thumb:hover {
            background: var(--amp-light-gray);
        }

        .sidebar-item {
            width: 100%;
            aspect-ratio: 16/9;
            margin-bottom: 12px;
            border: 2px solid transparent;
            cursor: pointer;
            overflow: hidden;
            position: relative;
            background: var(--amp-black);
            transition: border-color 0.2s ease;
        }

        .sidebar-item:hover {
            border-color: var(--amp-mid-gray);
        }

        .sidebar-item.active {
            border-color: var(--amp-lime);
        }

        .sidebar-item iframe {
            width: 1000%;
            height: 1000%;
            transform: scale(0.1);
            transform-origin: top left;
            pointer-events: none;
            border: none;
        }

        .sidebar-number {
            position: absolute;
            bottom: 4px;
            right: 4px;
            background: rgba(10, 10, 10, 0.8);
            color: var(--amp-white);
            font-family: var(--font-body);
            font-size: 10px;
            font-weight: 600;
            padding: 2px 6px;
        }

        /* Adjust presentation content for sidebar */
        .presentation-body {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .presentation-main {
            flex: 1;
            margin-left: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 24px;
            overflow: hidden;
        }

        /* Slide transition effect */
        .slide-container iframe {
            width: 1920px;
            height: 1080px;
            border: none;
            transform-origin: top left;
            transition: opacity 0.3s ease;
        }

        .slide-container iframe.transitioning {
            opacity: 0;
        }

        /* ═══════════════════════════════════════════════════════════════════════ */
        /* PROGRESS MODAL                                                           */
        /* ═══════════════════════════════════════════════════════════════════════ */
        .progress-modal {
            position: fixed;
            inset: 0;
            background: rgba(10, 10, 10, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .progress-modal.hidden {
            display: none;
        }

        .progress-modal-card {
            background: var(--amp-dark-alt);
            border: 1px solid var(--amp-mid-gray);
            padding: 40px;
            min-width: 400px;
            text-align: center;
        }

        .progress-title {
            font-family: var(--font-heading);
            font-size: 18px;
            font-weight: 400;
            color: var(--amp-white);
            margin: 0 0 8px 0;
        }

        .progress-bar-container {
            height: 8px;
            background: var(--amp-mid-gray);
            margin: 20px 0;
        }

        .progress-bar {
            height: 100%;
            background: var(--amp-lime);
            width: 0%;
            transition: width 0.2s ease;
        }

        .progress-text {
            font-family: var(--font-body);
            font-size: 14px;
            color: var(--amp-light-gray);
            margin: 0;
        }

        /* ═══════════════════════════════════════════════════════════════════════ */
        /* FULLSCREEN MODE - Hide sidebar for distraction-free presentation        */
        /* ═══════════════════════════════════════════════════════════════════════ */
        #presentation-view:fullscreen .presentation-sidebar,
        #presentation-view:-webkit-full-screen .presentation-sidebar,
        #presentation-view:fullscreen .animation-builder-panel,
        #presentation-view:-webkit-full-screen .animation-builder-panel {
            display: none;
        }

        #presentation-view:fullscreen .presentation-main,
        #presentation-view:-webkit-full-screen .presentation-main {
            margin-left: 0;
            padding: 0;
        }

        #presentation-view:fullscreen .keyboard-hint,
        #presentation-view:-webkit-full-screen .keyboard-hint {
            display: none;
        }

        #presentation-view:fullscreen .slide-container,
        #presentation-view:-webkit-full-screen .slide-container {
            border: none;
        }

        #presentation-view:fullscreen .presentation-header,
        #presentation-view:-webkit-full-screen .presentation-header {
            display: none;
        }

        /* Connection Status Indicator */
        .connection-status {
            display: flex;
            align-items: center;
            gap: 6px;
            font-family: var(--font-body);
            font-size: 12px;
            color: var(--amp-light-gray);
            padding: 4px 10px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.05);
            transition: all 0.3s ease;
        }

        .connection-status .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            transition: background-color 0.3s ease;
        }

        .connection-status.connected .status-dot {
            background: var(--amp-lime);
        }

        .connection-status.saving .status-dot {
            background: var(--amp-teal);
            animation: pulse 1s infinite;
        }

        .connection-status.saved .status-dot {
            background: var(--amp-lime);
        }

        .connection-status.disconnected .status-dot {
            background: #ef4444;
        }

        .connection-status.saved .status-text::after {
            content: ' ✓';
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }
    </style>
</head>
<body>
    <!-- ═══════════════════════════════════════════════════════════════════════ -->
    <!-- GALLERY VIEW                                                             -->
    <!-- ═══════════════════════════════════════════════════════════════════════ -->
    <div id="gallery-view">
        <header class="header">
            <div class="deck-badge">{{TOTAL_SLIDES}} Slides</div>
            <h1 class="title">{{DECK_NAME}}</h1>
            <p class="subtitle">Click any slide to enter presentation mode</p>
        </header>

        <div class="grid" id="slide-grid">
            <!-- Slides will be inserted here by JavaScript -->
        </div>
    </div>

    <!-- ═══════════════════════════════════════════════════════════════════════ -->
    <!-- PRESENTATION VIEW                                                        -->
    <!-- ═══════════════════════════════════════════════════════════════════════ -->
    <div id="presentation-view" class="hidden">
        <div class="presentation-header">
            <div style="display: flex; align-items: center; gap: 16px;">
                <span class="presentation-title">{{DECK_NAME}}</span>
                <div class="connection-status" id="connection-status" title="Server connection status">
                    <span class="status-dot"></span>
                    <span class="status-text">Checking...</span>
                </div>
            </div>
            <div class="presentation-controls">
                <button class="nav-btn" id="prev-btn" onclick="prevSlide()">← Previous</button>
                <span class="slide-counter" id="slide-counter">1 / {{TOTAL_SLIDES}}</span>
                <button class="nav-btn" id="next-btn" onclick="nextSlide()">Next →</button>
                <div class="download-wrapper">
                    <button class="download-btn" onclick="toggleDownloadMenu(event)" title="Download (D)">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                            <polyline points="7 10 12 15 17 10"/>
                            <line x1="12" y1="15" x2="12" y2="3"/>
                        </svg>
                    </button>
                    <div class="download-menu hidden" id="download-menu">
                        <button class="download-menu-item" onclick="downloadCurrentSlide()">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"/>
                                <circle cx="8.5" cy="8.5" r="1.5"/>
                                <polyline points="21 15 16 10 5 21"/>
                            </svg>
                            <span>Download Current Slide (PNG)</span>
                        </button>
                        <button class="download-menu-item" onclick="downloadAllSlidesPNG()">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
                                <line x1="12" y1="11" x2="12" y2="17"/>
                                <polyline points="9 14 12 17 15 14"/>
                            </svg>
                            <span>Download All Slides (ZIP)</span>
                        </button>
                        <button class="download-menu-item" onclick="downloadDeckPDF()">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/>
                                <polyline points="14 2 14 8 20 8"/>
                                <line x1="16" y1="13" x2="8" y2="13"/>
                                <line x1="16" y1="17" x2="8" y2="17"/>
                                <polyline points="10 9 9 9 8 9"/>
                            </svg>
                            <span>Download as PDF</span>
                        </button>
                    </div>
                </div>
                <button class="build-btn" id="build-btn" onclick="toggleAnimationBuilder()" title="Animation Builder (B)">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="3" y="3" width="18" height="7" rx="1"/>
                        <rect x="3" y="14" width="18" height="7" rx="1"/>
                    </svg>
                </button>
                <button class="close-btn" onclick="exitToGallery()" title="Close (Esc)">×</button>
            </div>
        </div>
        <div class="presentation-body">
            <!-- Thumbnail Sidebar -->
            <div class="presentation-sidebar" id="sidebar">
                <!-- Sidebar items will be rendered by JavaScript -->
            </div>
            <!-- Animation Builder Panel -->
            <div class="animation-builder-panel hidden" id="animation-builder-panel">
                <div class="builder-header">
                    <div class="builder-title">
                        Slide Builds
                        <button class="builder-done-btn" onclick="exitAnimationBuilder()">Done</button>
                    </div>
                    <div class="builder-instructions">
                        Click elements to select. Shift+click for multi-select. Group selected elements to animate together.
                    </div>
                </div>
                <div class="builder-selection-count" id="builder-selection-count">
                    0 selected
                </div>
                <button class="builder-create-group-btn" id="builder-create-group-btn" onclick="createAnimationGroup()" disabled>
                    + Create Group
                </button>
                <div class="builder-groups-list" id="builder-groups-list">
                    <!-- Groups will be rendered here -->
                </div>
                <div class="builder-footer">
                    <div class="builder-footer-note">
                        Ungrouped elements appear immediately. Groups animate in order during presentation.
                    </div>
                    <button class="builder-export-btn" onclick="exportAnimationsToManifest()" title="Save animations to manifest.json">
                        Save to Manifest
                    </button>
                </div>
            </div>
            <!-- Main Content Area -->
            <div class="presentation-main">
                <div class="slide-container">
                    <iframe id="presentation-iframe" src=""></iframe>
                </div>
            </div>
        </div>
        <div class="keyboard-hint">
            <kbd>←</kbd><kbd>→</kbd> Navigate
            <kbd>1-9</kbd> Jump
            <kbd>Home</kbd><kbd>End</kbd> First/Last
            <kbd>F</kbd> Fullscreen
            <kbd>D</kbd> Download
            <kbd>B</kbd> Builds
            <kbd>Esc</kbd> Exit
        </div>
    </div>

    <!-- ═══════════════════════════════════════════════════════════════════════ -->
    <!-- PROGRESS MODAL                                                           -->
    <!-- ═══════════════════════════════════════════════════════════════════════ -->
    <div id="progress-modal" class="progress-modal hidden">
        <div class="progress-modal-card">
            <h3 class="progress-title" id="progress-title">Exporting...</h3>
            <div class="progress-bar-container">
                <div class="progress-bar" id="progress-bar"></div>
            </div>
            <p class="progress-text" id="progress-text">Processing slide 1 of 14...</p>
        </div>
    </div>

    <!-- External libraries loaded from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>


    <script>
        // ═══════════════════════════════════════════════════════════════════════
        // SLIDE DATA
        // Fallback data injected at build time (works with file:// protocol)
        // Dynamic manifest loading attempted for server deployments
        // ═══════════════════════════════════════════════════════════════════════
        const FALLBACK_SLIDES = {{SLIDE_LIST}};
        const SLIDE_HTML_BASE64 = {{SLIDE_HTML_BASE64}};
        let slides = FALLBACK_SLIDES;
        let deckName = '{{DECK_NAME}}';
        let deckSlug = '{{DECK_SLUG}}';
        let totalSlides = {{TOTAL_SLIDES}};

        // ═══════════════════════════════════════════════════════════════════════
        // STATE
        // ═══════════════════════════════════════════════════════════════════════
        let currentSlide = 1;
        let builderMode = false;
        let selectedElements = new Set();
        let selectedGroupId = null;  // Currently selected group for editing membership

        // Build state for fullscreen presentation playback
        let buildState = {
            currentBuildStep: 0,    // 0 = no groups shown, 1+ = groups revealed
            totalBuildSteps: 0,     // Number of animation groups for current slide
            slideFullyBuilt: false, // True when all groups revealed or no groups exist
            nextSlideFullyBuilt: false, // Flag: next slide should appear fully built
            isTransitioning: false  // Flag: slide transition in progress, block navigation
        };

        // Server connection state for slide persistence
        let serverConnection = {
            connected: false,
            checking: false,
            saveTimeout: null,
            lastSaveAttempt: null
        };

        // ═══════════════════════════════════════════════════════════════════════
        // SERVER CONNECTION & SLIDE PERSISTENCE
        // ═══════════════════════════════════════════════════════════════════════

        /**
         * Get the base URL for the save server
         * Universal save server expects: /{deck-slug}/slides/{file}
         * Dev server (serve-deck.js) expects: /slides/{file}
         * /status endpoint never has deck slug prefix
         */
        function getSaveServerUrl(path) {
            const isFileProtocol = window.location.protocol === 'file:';
            const isDevServer = window.location.host === 'localhost:3000';

            if (isFileProtocol || !isDevServer) {
                // Universal save server
                if (path === '/status') {
                    return 'http://localhost:3000/status';
                }
                // Include deck slug for slide/manifest paths
                return `http://localhost:3000/${deckSlug}${path}`;
            }
            // Dev server (serve-deck.js) - use relative path
            return path;
        }

        /**
         * Update the connection status indicator in the UI
         * @param {string} status - 'connected', 'disconnected', 'saving', 'saved'
         * @param {string} text - Optional text to display
         */
        function updateConnectionStatus(status, text) {
            const indicator = document.getElementById('connection-status');
            if (!indicator) return;

            indicator.className = 'connection-status ' + status;
            const textEl = indicator.querySelector('.status-text');
            if (textEl) {
                const statusText = {
                    'connected': 'Connected',
                    'disconnected': 'Offline',
                    'saving': 'Saving...',
                    'saved': 'Saved'
                };
                textEl.textContent = text || statusText[status] || status;
            }

            // For 'saved' status, revert to 'connected' after 2 seconds
            if (status === 'saved') {
                setTimeout(() => {
                    if (serverConnection.connected) {
                        updateConnectionStatus('connected');
                    }
                }, 2000);
            }
        }

        /**
         * Check if the development server is running
         * @returns {Promise<boolean>} True if server is connected
         */
        async function checkServerConnection() {
            if (serverConnection.checking) return serverConnection.connected;
            serverConnection.checking = true;

            try {
                const response = await fetch(getSaveServerUrl('/status'), {
                    method: 'GET',
                    cache: 'no-store'
                });

                if (response.ok) {
                    const data = await response.json();
                    serverConnection.connected = data.status === 'connected';
                    updateConnectionStatus(serverConnection.connected ? 'connected' : 'disconnected');
                } else {
                    serverConnection.connected = false;
                    updateConnectionStatus('disconnected');
                }
            } catch (e) {
                serverConnection.connected = false;
                updateConnectionStatus('disconnected');
            }

            serverConnection.checking = false;
            return serverConnection.connected;
        }

        /**
         * Save slide content to server (with localStorage fallback)
         * @param {number} slideNumber - 1-indexed slide number
         * @param {string} htmlContent - Full HTML content of the slide
         * @returns {Promise<boolean>} True if saved successfully
         */
        async function saveSlideToServer(slideNumber, htmlContent) {
            const slideFile = `slide-${slideNumber}.html`;

            // Try server first
            if (serverConnection.connected) {
                try {
                    updateConnectionStatus('saving');
                    const response = await fetch(getSaveServerUrl(`/slides/${slideFile}`), {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'text/html'
                        },
                        body: htmlContent
                    });

                    if (response.ok) {
                        updateConnectionStatus('saved');
                        // Also clear localStorage for this slide since server is source of truth
                        localStorage.removeItem(`slide-${slideNumber}-edits`);
                        return true;
                    } else {
                        console.warn('Server save failed:', await response.text());
                    }
                } catch (e) {
                    console.warn('Server save error:', e);
                    serverConnection.connected = false;
                    updateConnectionStatus('disconnected');
                }
            }

            // Fallback to localStorage
            try {
                localStorage.setItem(`slide-${slideNumber}-edits`, htmlContent);
                updateConnectionStatus('disconnected', 'Saved locally');
                return true;
            } catch (e) {
                console.error('localStorage save failed:', e);
                return false;
            }
        }

        /**
         * Set up save handlers for editable content in an iframe
         * @param {HTMLIFrameElement} iframe - The slide iframe
         * @param {number} slideNumber - 1-indexed slide number
         */
        function setupSlideEditHandlers(iframe, slideNumber) {
            if (!iframe || !iframe.contentDocument) return;

            const doc = iframe.contentDocument;
            const editableElements = doc.querySelectorAll('[contenteditable="true"]');

            // Debounced save function
            const debouncedSave = () => {
                if (serverConnection.saveTimeout) {
                    clearTimeout(serverConnection.saveTimeout);
                }
                serverConnection.saveTimeout = setTimeout(() => {
                    const html = '<!DOCTYPE html>\n' + doc.documentElement.outerHTML;
                    saveSlideToServer(slideNumber, html);
                }, 500);
            };

            // Immediate save on blur
            const saveOnBlur = () => {
                if (serverConnection.saveTimeout) {
                    clearTimeout(serverConnection.saveTimeout);
                    serverConnection.saveTimeout = null;
                }
                const html = '<!DOCTYPE html>\n' + doc.documentElement.outerHTML;
                saveSlideToServer(slideNumber, html);
            };

            editableElements.forEach(el => {
                // Save on input (debounced)
                el.addEventListener('input', debouncedSave);
                // Save on blur (immediate)
                el.addEventListener('blur', saveOnBlur);
            });
        }

        // ═══════════════════════════════════════════════════════════════════════
        // BUILD PLAYBACK FUNCTIONS (Fullscreen Only)
        // ═══════════════════════════════════════════════════════════════════════

        /**
         * Check if currently in fullscreen mode
         * @returns {boolean} True if in fullscreen
         */
        function isInFullscreen() {
            return !!(document.fullscreenElement || document.webkitFullscreenElement);
        }

        /**
         * Initialize build state for a slide
         * Called when entering fullscreen or navigating slides in fullscreen
         * @param {number} slideNumber - 1-indexed slide number
         * @param {boolean} fullyBuilt - If true, show all groups (for navigating back)
         * @param {boolean} immediate - If true, apply immediately; if false, wait for iframe load
         */
        function initializeBuildState(slideNumber, fullyBuilt = false, immediate = false) {
            const slide = slides[slideNumber - 1];
            const groups = slide?.animations?.groups || [];

            buildState.totalBuildSteps = groups.length;
            buildState.slideFullyBuilt = groups.length === 0;

            if (fullyBuilt && groups.length > 0) {
                // Coming from previous slide, show fully built
                buildState.currentBuildStep = groups.length;
                buildState.slideFullyBuilt = true;
                if (immediate) {
                    showAllGroupedElements();
                } else {
                    // Wait a bit for iframe to load
                    setTimeout(() => showAllGroupedElements(), 200);
                }
            } else {
                // Normal entry, hide all animated elements
                buildState.currentBuildStep = 0;
                if (groups.length > 0 && isInFullscreen() && !builderMode) {
                    if (immediate) {
                        hideAnimatedElements(groups);
                    } else {
                        // Wait a bit for iframe to load
                        setTimeout(() => hideAnimatedElements(groups), 200);
                    }
                }
            }

            // Clear transition lock - slide is ready for interaction
            buildState.isTransitioning = false;
        }

        /**
         * Send a build command to the iframe via postMessage
         * Works regardless of cross-origin restrictions
         * @param {string} command - Command type: buildHideElements, buildRevealElements, buildShowAll
         * @param {string[]} elementIds - Array of element IDs to target
         */
        function sendBuildCommand(command, elementIds = []) {
            const iframe = document.getElementById('presentation-iframe');
            if (!iframe || !iframe.contentWindow) return;

            iframe.contentWindow.postMessage({
                type: command,
                elementIds: elementIds
            }, '*');
        }

        /**
         * Hide all animated elements that belong to groups
         * Uses postMessage for cross-origin compatibility
         * @param {Array} groups - Animation groups from slide data
         */
        function hideAnimatedElements(groups) {
            // Collect all element IDs that are in groups
            const elementIds = [];
            groups.forEach(group => {
                group.elementIds.forEach(id => elementIds.push(id));
            });

            if (elementIds.length > 0) {
                sendBuildCommand('buildHideElements', elementIds);
            }
        }

        /**
         * Reveal a specific animation group
         * Uses postMessage for cross-origin compatibility
         * @param {number} stepNumber - The build step (1-indexed, matches group order)
         */
        function revealGroup(stepNumber) {
            const slide = slides[currentSlide - 1];
            const groups = slide?.animations?.groups || [];
            const group = groups.find(g => g.order === stepNumber);
            if (!group || !group.elementIds.length) return;

            sendBuildCommand('buildRevealElements', group.elementIds);
        }

        /**
         * Hide a specific animation group (reverse build)
         * Uses postMessage for cross-origin compatibility
         * @param {number} stepNumber - The build step (1-indexed, matches group order)
         */
        function hideGroup(stepNumber) {
            const slide = slides[currentSlide - 1];
            const groups = slide?.animations?.groups || [];
            const group = groups.find(g => g.order === stepNumber);
            if (!group || !group.elementIds.length) return;

            sendBuildCommand('buildHideElements', group.elementIds);
        }

        /**
         * Show all grouped elements (for exiting fullscreen or showing fully built)
         * Uses postMessage for cross-origin compatibility
         */
        function showAllGroupedElements() {
            sendBuildCommand('buildShowAll');
        }

        /**
         * Advance to next build step or next slide
         * Called on Right Arrow / Click / Space in fullscreen
         */
        function advanceBuild() {
            // Block during slide transitions
            if (buildState.isTransitioning) return;

            // Skip build logic in builder mode or not in fullscreen
            if (builderMode || !isInFullscreen()) {
                nextSlide();
                return;
            }

            if (buildState.currentBuildStep < buildState.totalBuildSteps) {
                // Reveal next group
                buildState.currentBuildStep++;
                revealGroup(buildState.currentBuildStep);

                if (buildState.currentBuildStep >= buildState.totalBuildSteps) {
                    buildState.slideFullyBuilt = true;
                }
            } else {
                // Slide fully built, go to next slide
                buildState.isTransitioning = true; // Block until slide loads
                nextSlide();
            }
        }

        /**
         * Reverse build step or go to previous slide (fully built)
         * Called on Left Arrow in fullscreen
         */
        function reverseBuild() {
            // Block during slide transitions
            if (buildState.isTransitioning) return;

            // Skip build logic in builder mode or not in fullscreen
            if (builderMode || !isInFullscreen()) {
                prevSlide();
                return;
            }

            if (buildState.currentBuildStep > 0) {
                // Hide current group
                hideGroup(buildState.currentBuildStep);
                buildState.currentBuildStep--;
                buildState.slideFullyBuilt = false;
            } else {
                // At step 0, go to previous slide (show it fully built)
                if (currentSlide > 1) {
                    buildState.nextSlideFullyBuilt = true;
                    buildState.isTransitioning = true;
                    currentSlide--;
                    updatePresentationSlide();
                }
            }
        }

        /**
         * Handle fullscreen exit - show all elements
         */
        function onFullscreenExit() {
            if (!isInFullscreen()) {
                // Exited fullscreen, show all elements
                showAllGroupedElements();
                // Reset build state
                buildState.currentBuildStep = 0;
                buildState.slideFullyBuilt = true;
                buildState.isTransitioning = false;
            }
        }

        /**
         * Handle fullscreen enter - initialize build state
         */
        function onFullscreenEnter() {
            if (isInFullscreen() && !builderMode) {
                // Slide is already loaded, apply immediately
                initializeBuildState(currentSlide, false, true);
            }
        }

        // ═══════════════════════════════════════════════════════════════════════
        // ANIMATION DATA SCHEMA
        // Each slide in the slides array can have an optional 'animations' field:
        //
        // slides[n].animations = {
        //   groups: [
        //     {
        //       id: string,        // Unique group identifier (e.g., "group-1")
        //       order: number,     // Build order (1 = first to appear)
        //       elementIds: string[] // Array of data-build-id values
        //     }
        //   ]
        // }
        //
        // Storage behavior:
        // - http:// protocol: Save directly to manifest.json via PUT request
        // - file:// protocol: Save to localStorage with key "animations-{deckName}"
        // ═══════════════════════════════════════════════════════════════════════

        /**
         * Detect if running under file:// protocol (local file system)
         * @returns {boolean} True if file:// protocol, false otherwise
         */
        function isFileProtocol() {
            return window.location.protocol === 'file:';
        }

        /**
         * Load animations from localStorage (used for file:// protocol)
         * Only merges localStorage animations if manifest doesn't have them
         * Manifest is the source of truth - localStorage is backup only
         */
        function loadAnimationsFromLocalStorage() {
            try {
                const storageKey = `animations-${deckName}`;
                const storedData = localStorage.getItem(storageKey);
                if (!storedData) return;

                const storedSlides = JSON.parse(storedData);
                if (!Array.isArray(storedSlides)) return;

                // Only use localStorage animations if manifest doesn't have them
                // This prevents stale localStorage from overwriting good manifest data
                storedSlides.forEach((storedSlide, index) => {
                    if (storedSlide.animations && slides[index]) {
                        // Only use localStorage if current slide has no animations or empty groups
                        const hasManifestAnimations = slides[index].animations?.groups?.length > 0;
                        if (!hasManifestAnimations) {
                            slides[index].animations = storedSlide.animations;
                        }
                    }
                });
            } catch (e) {
                console.warn('Failed to load animations from localStorage:', e);
            }
        }

        /**
         * Save animations to persistent storage
         * Uses manifest.json for http:// or localStorage for file://
         * @param {number} [slideIndex] - Optional specific slide index to update
         */
        /**
         * Save animations to persistent storage
         * Primary: manifest.json (source of truth)
         * Backup: localStorage (for when manifest write fails)
         */
        async function saveAnimations(slideIndex) {
            const storageKey = `animations-${deckName}`;

            // Always save to localStorage as backup
            try {
                localStorage.setItem(storageKey, JSON.stringify(slides));
            } catch (e) {
                console.warn('[Animations] localStorage backup failed:', e);
            }

            // Try to save to manifest.json via save server
            try {
                const response = await fetch(getSaveServerUrl('/slides/manifest.json'), {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        deckName,
                        generatedAt: new Date().toISOString(),
                        slides
                    }, null, 2)
                });
                if (response.ok) {
                    console.log('[Animations] Saved to manifest.json');
                    return;
                }
            } catch (e) {
                // PUT failed, localStorage backup is in place
            }

            console.log('[Animations] Saved to localStorage (manifest write not available)');
        }

        /**
         * Export animations to a downloadable manifest.json file
         * User should save this to output/{deck}/slides/manifest.json to persist animations
         */
        function exportAnimationsToManifest() {
            const manifest = {
                deckName,
                generatedAt: new Date().toISOString(),
                slides: slides
            };

            const blob = new Blob([JSON.stringify(manifest, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = 'manifest.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            console.log('[Animations] Exported manifest.json with animations');
            alert('Downloaded manifest.json\\n\\nSave it to: output/' + deckName.toLowerCase().replace(/\\s+/g, '-') + '/slides/manifest.json');
        }

        // ═══════════════════════════════════════════════════════════════════════
        // ANIMATION BUILDER FUNCTIONS
        // Uses overlay approach for file:// protocol compatibility
        // ═══════════════════════════════════════════════════════════════════════

        // Builder state
        let builderElements = []; // Array of {id, rect} for current slide
        let hoveredElementId = null;

        /**
         * Toggle animation builder mode on/off
         */
        function toggleAnimationBuilder() {
            if (builderMode) {
                exitAnimationBuilder();
            } else {
                enterAnimationBuilder();
            }
        }

        /**
         * Enter animation builder mode
         */
        function enterAnimationBuilder() {
            builderMode = true;
            selectedElements.clear();
            builderElements = [];
            hoveredElementId = null;

            // Update UI
            document.getElementById('build-btn').classList.add('active');
            document.getElementById('sidebar').classList.add('hidden');
            document.getElementById('animation-builder-panel').classList.remove('hidden');

            // Close download menu if open
            closeDownloadMenu();

            // Create and show overlay
            createBuilderOverlay();

            // Scan iframe for elements after it loads
            const iframe = document.getElementById('presentation-iframe');
            if (iframe) {
                // Wait a moment for iframe to be ready
                setTimeout(() => {
                    scanSlideElements();
                }, 100);
            }

            // Render existing groups for this slide
            renderGroups();
            updateSelectionCount();
            updateCreateGroupButton();

            console.log('Entered animation builder mode');
        }

        /**
         * Exit animation builder mode
         */
        function exitAnimationBuilder() {
            builderMode = false;
            selectedGroupId = null;  // Clear group selection
            selectedElements.clear();
            builderElements = [];
            hoveredElementId = null;

            // Clear any group highlights from slide
            clearGroupHighlights();

            // Remove overlay
            removeBuilderOverlay();

            // Update UI
            document.getElementById('build-btn').classList.remove('active');
            document.getElementById('animation-builder-panel').classList.add('hidden');
            document.getElementById('sidebar').classList.remove('hidden');

            console.log('Exited animation builder mode');
        }

        /**
         * Create the builder overlay for element selection
         */
        function createBuilderOverlay() {
            // Remove existing overlay if any
            removeBuilderOverlay();

            const container = document.querySelector('.slide-container');
            if (!container) return;

            // Create overlay div
            const overlay = document.createElement('div');
            overlay.id = 'builder-overlay';
            overlay.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                z-index: 10;
                cursor: crosshair;
            `;

            // Create SVG for drawing highlights
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.id = 'builder-highlights';
            svg.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
            `;
            overlay.appendChild(svg);

            // Add event listeners
            overlay.addEventListener('mousemove', handleOverlayMouseMove);
            overlay.addEventListener('click', handleOverlayClick);

            container.style.position = 'relative';
            container.appendChild(overlay);
        }

        /**
         * Remove the builder overlay
         */
        function removeBuilderOverlay() {
            const overlay = document.getElementById('builder-overlay');
            if (overlay) {
                overlay.removeEventListener('mousemove', handleOverlayMouseMove);
                overlay.removeEventListener('click', handleOverlayClick);
                overlay.remove();
            }
        }

        /**
         * Scan slide iframe for buildable elements and store their positions
         */
        function scanSlideElements() {
            builderElements = [];

            const iframe = document.getElementById('presentation-iframe');
            const container = document.querySelector('.slide-container');
            if (!iframe || !container) return;

            // Get iframe scale
            const iframeRect = iframe.getBoundingClientRect();
            const containerRect = container.getBoundingClientRect();
            const scale = iframeRect.width / 1920; // Original slide width

            try {
                const slideDoc = iframe.contentDocument || iframe.contentWindow?.document;
                if (!slideDoc) {
                    console.warn('Cannot access iframe content - using fallback element detection');
                    useFallbackElementDetection();
                    return;
                }

                // Selectors for buildable elements - prefer specific/leaf elements
                // Priority: contenteditable fields first, then structural elements
                const selectors = [
                    // User-editable fields (most important - these are what users want to animate)
                    '[contenteditable="true"]',
                    '[data-field]',
                    // Text elements
                    'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
                    'p:not(.key-point-text):not(.insight-text)', // Avoid duplicates with contenteditable
                    'li',
                    'blockquote',
                    // Slide-specific components (from your generated slides)
                    '.key-point',
                    '.insight-box',
                    '.section-label',
                    '.logo',
                    '.stat-item',
                    '.timeline-item',
                    '.feature-card',
                    '.comparison-item',
                    '.agenda-item',
                    '.process-step',
                    '.quote-block',
                    // Generic components
                    '.card',
                    '.box',
                    '.callout',
                    '.stat',
                    '.metric',
                    '.step',
                    '.item',
                    '.point',
                    // Media
                    'img',
                    // Icon containers with meaningful content
                    '.key-point-icon',
                    '.icon-box',
                    '[class*="-icon"]:not(svg)'
                ];

                const elements = slideDoc.querySelectorAll(selectors.join(', '));
                let idCounter = 1;
                const tempElements = [];

                elements.forEach(el => {
                    // Skip very small elements or invisible ones
                    const rect = el.getBoundingClientRect();
                    if (rect.width < 10 || rect.height < 10) return;

                    // Skip if element is too large (likely a container) - more than 80% of slide
                    if (rect.width > 1536 || rect.height > 864) return; // 80% of 1920x1080

                    // Skip elements that are mostly transparent/empty containers
                    const computedStyle = slideDoc.defaultView.getComputedStyle(el);
                    if (computedStyle.display === 'none' || computedStyle.visibility === 'hidden') return;

                    // Assign build ID if not present
                    let buildId = el.getAttribute('data-build-id');
                    if (!buildId) {
                        buildId = `build-${idCounter}`;
                        el.setAttribute('data-build-id', buildId);
                    }
                    idCounter++;

                    // Store scaled rect relative to overlay
                    const area = rect.width * rect.height;
                    tempElements.push({
                        id: buildId,
                        rect: {
                            x: rect.left * scale,
                            y: rect.top * scale,
                            width: rect.width * scale,
                            height: rect.height * scale
                        },
                        tagName: el.tagName.toLowerCase(),
                        text: el.textContent?.substring(0, 50) || '',
                        area: area * scale * scale
                    });
                });

                // Sort by area (smallest first) so smaller elements take priority in hit detection
                tempElements.sort((a, b) => a.area - b.area);
                builderElements = tempElements;

                console.log(`Scanned ${builderElements.length} buildable elements`);
            } catch (e) {
                console.warn('Error scanning iframe:', e);
                useFallbackElementDetection();
            }
        }

        /**
         * Fallback when iframe content is not accessible
         * Uses postMessage to ask the slide to report its elements
         */
        function useFallbackElementDetection() {
            const iframe = document.getElementById('presentation-iframe');
            if (!iframe || !iframe.contentWindow) {
                console.warn('No iframe available for postMessage');
                useStaticFallback();
                return;
            }

            // Set up listener for response from iframe
            const messageHandler = (event) => {
                if (event.data && event.data.type === 'builderElements') {
                    window.removeEventListener('message', messageHandler);

                    const container = document.querySelector('.slide-container');
                    if (!container) return;

                    const containerRect = container.getBoundingClientRect();
                    const scale = containerRect.width / 1920;

                    // Convert received elements to overlay coordinates
                    builderElements = event.data.elements.map(el => ({
                        id: el.id,
                        rect: {
                            x: el.rect.x * scale,
                            y: el.rect.y * scale,
                            width: el.rect.width * scale,
                            height: el.rect.height * scale
                        },
                        tagName: el.tagName,
                        text: el.text,
                        area: el.rect.width * el.rect.height * scale * scale
                    }));

                    // Sort by area (smallest first)
                    builderElements.sort((a, b) => a.area - b.area);

                    console.log(`Received ${builderElements.length} elements via postMessage`);
                }
            };

            window.addEventListener('message', messageHandler);

            // Request elements from iframe
            iframe.contentWindow.postMessage({ type: 'getBuilderElements' }, '*');

            // Timeout fallback if no response
            setTimeout(() => {
                if (builderElements.length === 0) {
                    window.removeEventListener('message', messageHandler);
                    console.warn('No postMessage response, using static fallback');
                    useStaticFallback();
                }
            }, 500);
        }

        /**
         * Static fallback when postMessage also fails
         */
        function useStaticFallback() {
            const container = document.querySelector('.slide-container');
            if (!container) return;

            const containerRect = container.getBoundingClientRect();
            const scale = containerRect.width / 1920;

            // Create a more granular grid based on common slide layouts
            builderElements = [
                // Header region
                { id: 'region-logo', rect: { x: 80, y: 60, width: 200, height: 40 } },
                // Title area
                { id: 'region-title', rect: { x: 80, y: 200, width: 1760, height: 150 } },
                // Main content - split into sections
                { id: 'region-content-1', rect: { x: 80, y: 380, width: 1760, height: 250 } },
                { id: 'region-content-2', rect: { x: 80, y: 650, width: 560, height: 300 } },
                { id: 'region-content-3', rect: { x: 680, y: 650, width: 560, height: 300 } },
                { id: 'region-content-4', rect: { x: 1280, y: 650, width: 560, height: 300 } },
            ].map(r => ({
                id: r.id,
                rect: {
                    x: r.rect.x * scale,
                    y: r.rect.y * scale,
                    width: r.rect.width * scale,
                    height: r.rect.height * scale
                },
                tagName: 'region',
                text: r.id.replace('region-', ''),
                area: r.rect.width * r.rect.height * scale * scale
            }));

            // Sort by area
            builderElements.sort((a, b) => a.area - b.area);

            console.log('Using static fallback regions');
        }

        /**
         * Handle mouse move over the overlay
         */
        function handleOverlayMouseMove(e) {
            if (!builderMode) return;

            const overlay = document.getElementById('builder-overlay');
            if (!overlay) return;

            const rect = overlay.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Find element under cursor
            let foundElement = null;
            for (const el of builderElements) {
                if (x >= el.rect.x && x <= el.rect.x + el.rect.width &&
                    y >= el.rect.y && y <= el.rect.y + el.rect.height) {
                    foundElement = el;
                    break;
                }
            }

            const newHoveredId = foundElement?.id || null;
            if (newHoveredId !== hoveredElementId) {
                hoveredElementId = newHoveredId;
                renderHighlights();
            }
        }

        /**
         * Handle click on the overlay
         */
        function handleOverlayClick(e) {
            if (!builderMode) return;

            const overlay = document.getElementById('builder-overlay');
            if (!overlay) return;

            const rect = overlay.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Find element under cursor
            let foundElement = null;
            for (const el of builderElements) {
                if (x >= el.rect.x && x <= el.rect.x + el.rect.width &&
                    y >= el.rect.y && y <= el.rect.y + el.rect.height) {
                    foundElement = el;
                    break;
                }
            }

            if (!foundElement) return;

            const buildId = foundElement.id;

            // If a group is selected, toggle membership instead of normal selection
            if (selectedGroupId) {
                toggleGroupMembership(buildId);
                return;
            }

            // Normal selection behavior for creating new groups
            if (e.shiftKey) {
                // Shift+click: toggle selection
                if (selectedElements.has(buildId)) {
                    selectedElements.delete(buildId);
                } else {
                    selectedElements.add(buildId);
                }
            } else {
                // Regular click: select only this element
                selectedElements.clear();
                selectedElements.add(buildId);
            }

            renderHighlights();
            updateSelectionCount();
            updateCreateGroupButton();
        }

        /**
         * Render highlight rectangles on the overlay SVG
         */
        function renderHighlights() {
            const svg = document.getElementById('builder-highlights');
            if (!svg) return;

            // Clear existing highlights
            svg.innerHTML = '';

            // Draw hover highlight
            if (hoveredElementId && !selectedElements.has(hoveredElementId)) {
                const el = builderElements.find(e => e.id === hoveredElementId);
                if (el) {
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', el.rect.x);
                    rect.setAttribute('y', el.rect.y);
                    rect.setAttribute('width', el.rect.width);
                    rect.setAttribute('height', el.rect.height);
                    rect.setAttribute('fill', 'none');
                    rect.setAttribute('stroke', 'rgba(212, 233, 76, 0.6)');
                    rect.setAttribute('stroke-width', '2');
                    rect.setAttribute('stroke-dasharray', '5,5');
                    svg.appendChild(rect);
                }
            }

            // Draw selection highlights
            selectedElements.forEach(buildId => {
                const el = builderElements.find(e => e.id === buildId);
                if (el) {
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', el.rect.x - 2);
                    rect.setAttribute('y', el.rect.y - 2);
                    rect.setAttribute('width', el.rect.width + 4);
                    rect.setAttribute('height', el.rect.height + 4);
                    rect.setAttribute('fill', 'rgba(212, 233, 76, 0.1)');
                    rect.setAttribute('stroke', '#d4e94c');
                    rect.setAttribute('stroke-width', '3');
                    svg.appendChild(rect);
                }
            });
        }

        /**
         * Update the selection count display in the builder panel
         */
        function updateSelectionCount() {
            const countEl = document.getElementById('builder-selection-count');
            if (!countEl) return;

            if (selectedGroupId) {
                // Show group editing mode
                const slideData = slides[currentSlide - 1];
                const group = slideData?.animations?.groups?.find(g => g.id === selectedGroupId);
                if (group) {
                    countEl.innerHTML = `<strong>Editing Group ${group.order}</strong><br><span style="font-size: 10px; color: var(--amp-light-gray);">Click elements to add/remove</span>`;
                    countEl.style.background = 'rgba(212, 233, 76, 0.15)';
                }
            } else {
                // Normal selection mode
                const count = selectedElements.size;
                countEl.textContent = `${count} selected`;
                countEl.style.background = 'rgba(212, 233, 76, 0.1)';
            }
        }

        /**
         * Update the Create Group button state
         */
        function updateCreateGroupButton() {
            const btn = document.getElementById('builder-create-group-btn');
            if (!btn) return;

            // Disable when a group is selected (editing mode) OR no elements selected
            btn.disabled = selectedGroupId !== null || selectedElements.size === 0;

            if (selectedGroupId) {
                btn.textContent = 'Click group to deselect';
                btn.style.opacity = '0.5';
            } else {
                btn.textContent = '+ Create Group';
                btn.style.opacity = selectedElements.size === 0 ? '0.4' : '1';
            }
        }

        /**
         * Create a new animation group from selected elements
         */
        function createAnimationGroup() {
            if (selectedElements.size === 0) return;

            // Get or initialize animations for current slide
            const slideData = slides[currentSlide - 1];
            if (!slideData.animations) {
                slideData.animations = { groups: [] };
            }

            // Generate new group ID
            const groupNum = slideData.animations.groups.length + 1;
            const groupId = `group-${groupNum}`;

            // Create group with selected elements
            // Color is assigned at creation and persists through reordering
            const newGroup = {
                id: groupId,
                order: groupNum,
                colorIndex: groupNum % 5,
                elementIds: Array.from(selectedElements)
            };

            slideData.animations.groups.push(newGroup);

            // Clear selections
            selectedElements.clear();

            // Save animations
            saveAnimations(currentSlide - 1);

            // Re-render
            renderGroups();
            renderHighlights();
            updateSelectionCount();
            updateCreateGroupButton();

            console.log(`Created animation group: ${groupId} with ${newGroup.elementIds.length} elements`);
        }

        /**
         * Render the groups list in the builder panel
         */
        function renderGroups() {
            const groupsList = document.getElementById('builder-groups-list');
            if (!groupsList) return;

            const slideData = slides[currentSlide - 1];
            const groups = slideData?.animations?.groups || [];

            if (groups.length === 0) {
                groupsList.innerHTML = '<div style="color: var(--amp-light-gray); font-size: 11px; text-align: center; padding: 20px;">No groups yet. Select elements and click Create Group.</div>';
                return;
            }

            // Ensure all groups have a colorIndex (migrate old groups)
            let needsSave = false;
            groups.forEach(group => {
                if (group.colorIndex === undefined) {
                    const idNum = parseInt(group.id.replace('group-', ''), 10) || 0;
                    group.colorIndex = idNum % 5;
                    needsSave = true;
                }
            });
            if (needsSave) {
                saveAnimations(currentSlide - 1);
            }

            groupsList.innerHTML = groups.map((group, index) => {
                const isSelected = selectedGroupId === group.id;
                return `
                <div class="builder-group group-color-${group.colorIndex} ${isSelected ? 'group-selected' : ''}"
                     data-group-id="${group.id}"
                     onclick="selectGroup('${group.id}')">
                    <div class="builder-group-header">
                        <span class="builder-group-title">Group ${group.order}</span>
                        <span class="builder-group-count">${group.elementIds.length} element${group.elementIds.length !== 1 ? 's' : ''}</span>
                    </div>
                    <div class="builder-group-controls" onclick="event.stopPropagation()">
                        <button class="group-btn" onclick="moveGroupUp('${group.id}')" ${index === 0 ? 'disabled' : ''} title="Move up">▲</button>
                        <button class="group-btn" onclick="moveGroupDown('${group.id}')" ${index === groups.length - 1 ? 'disabled' : ''} title="Move down">▼</button>
                        <button class="group-btn group-delete" onclick="deleteGroup('${group.id}')" title="Delete group">×</button>
                    </div>
                </div>
                `;
            }).join('');
        }

        /**
         * Move a group up in the build order
         * @param {string} groupId - The group ID to move up
         */
        function moveGroupUp(groupId) {
            const slideData = slides[currentSlide - 1];
            const groups = slideData?.animations?.groups;
            if (!groups) return;

            const index = groups.findIndex(g => g.id === groupId);
            if (index <= 0) return;

            // Swap with previous
            [groups[index - 1], groups[index]] = [groups[index], groups[index - 1]];

            // Re-number orders
            groups.forEach((g, i) => g.order = i + 1);

            saveAnimations(currentSlide - 1);
            renderGroups();

            console.log(`Moved group ${groupId} up to position ${index}`);
        }

        /**
         * Move a group down in the build order
         * @param {string} groupId - The group ID to move down
         */
        function moveGroupDown(groupId) {
            const slideData = slides[currentSlide - 1];
            const groups = slideData?.animations?.groups;
            if (!groups) return;

            const index = groups.findIndex(g => g.id === groupId);
            if (index < 0 || index >= groups.length - 1) return;

            // Swap with next
            [groups[index], groups[index + 1]] = [groups[index + 1], groups[index]];

            // Re-number orders
            groups.forEach((g, i) => g.order = i + 1);

            saveAnimations(currentSlide - 1);
            renderGroups();

            console.log(`Moved group ${groupId} down to position ${index + 2}`);
        }

        /**
         * Delete a group from the animation build order
         * @param {string} groupId - The group ID to delete
         */
        function deleteGroup(groupId) {
            const slideData = slides[currentSlide - 1];
            const groups = slideData?.animations?.groups;
            if (!groups) return;

            // Remove group
            const index = groups.findIndex(g => g.id === groupId);
            if (index < 0) return;

            const deletedGroup = groups[index];
            groups.splice(index, 1);

            // Re-number remaining groups
            groups.forEach((g, i) => g.order = i + 1);

            saveAnimations(currentSlide - 1);
            renderGroups();

            console.log(`Deleted group ${groupId} (had ${deletedGroup.elementIds.length} elements)`);
        }

        // ═══════════════════════════════════════════════════════════════════════
        // GROUP SELECTION & MEMBERSHIP EDITING
        // ═══════════════════════════════════════════════════════════════════════

        /**
         * Select a group for membership editing
         * @param {string} groupId - The group ID to select
         */
        function selectGroup(groupId) {
            const slideData = slides[currentSlide - 1];
            const groups = slideData?.animations?.groups || [];
            const group = groups.find(g => g.id === groupId);

            if (!group) return;

            // If clicking same group, deselect
            if (selectedGroupId === groupId) {
                deselectGroup();
                return;
            }

            // Select this group
            selectedGroupId = groupId;

            // Clear normal element selection (for new group creation)
            selectedElements.clear();

            // Update UI
            renderGroups();  // Re-render to show selected state
            highlightGroupElements(group);  // Highlight elements on slide
            updateSelectionCount();
            updateCreateGroupButton();

            console.log(`Selected group ${groupId} for editing (${group.elementIds.length} elements)`);
        }

        /**
         * Deselect the currently selected group
         */
        function deselectGroup() {
            if (!selectedGroupId) return;

            console.log(`Deselected group ${selectedGroupId}`);
            selectedGroupId = null;
            clearGroupHighlights();
            renderGroups();
            renderHighlights();  // Restore normal selection highlights
            updateSelectionCount();
            updateCreateGroupButton();
        }

        /**
         * Highlight elements belonging to the selected group on the slide
         * @param {Object} group - The group object with elementIds and colorIndex
         */
        function highlightGroupElements(group) {
            const iframe = document.getElementById('presentation-iframe');
            if (!iframe) return;

            const iframeDoc = iframe.contentDocument || iframe.contentWindow?.document;
            if (!iframeDoc) return;

            // Clear any existing group highlights
            clearGroupHighlights(iframeDoc);

            // Inject group highlight CSS if not present
            injectGroupHighlightCSS(iframeDoc);

            // Apply highlight to each element in group
            const colorClass = `group-highlight-${group.colorIndex}`;
            group.elementIds.forEach(buildId => {
                const el = iframeDoc.querySelector(`[data-build-id="${buildId}"]`);
                if (el) {
                    el.classList.add('group-member-highlight', colorClass);
                }
            });
        }

        /**
         * Clear all group membership highlights from slide
         * @param {Document} [iframeDoc] - Optional iframe document
         */
        function clearGroupHighlights(iframeDoc) {
            if (!iframeDoc) {
                const iframe = document.getElementById('presentation-iframe');
                iframeDoc = iframe?.contentDocument || iframe?.contentWindow?.document;
            }
            if (!iframeDoc) return;

            iframeDoc.querySelectorAll('.group-member-highlight').forEach(el => {
                el.classList.remove(
                    'group-member-highlight',
                    'group-highlight-0', 'group-highlight-1',
                    'group-highlight-2', 'group-highlight-3', 'group-highlight-4'
                );
            });
        }

        /**
         * Inject CSS for group membership highlights into iframe
         * @param {Document} iframeDoc - The iframe's document
         */
        function injectGroupHighlightCSS(iframeDoc) {
            if (iframeDoc.getElementById('group-highlight-styles')) return;

            const style = iframeDoc.createElement('style');
            style.id = 'group-highlight-styles';
            style.textContent = `
                .group-member-highlight {
                    outline-width: 3px;
                    outline-style: solid;
                    outline-offset: 4px;
                    transition: outline-color 0.2s ease;
                }
                .group-highlight-0 { outline-color: #d4e94c; }  /* lime */
                .group-highlight-1 { outline-color: #2dd4bf; }  /* teal */
                .group-highlight-2 { outline-color: #a78bfa; }  /* purple */
                .group-highlight-3 { outline-color: #f97316; }  /* orange */
                .group-highlight-4 { outline-color: #ec4899; }  /* pink */
            `;
            iframeDoc.head.appendChild(style);
        }

        /**
         * Toggle an element's membership in the selected group
         * @param {string} buildId - The element's data-build-id
         */
        function toggleGroupMembership(buildId) {
            if (!selectedGroupId) return;

            const slideData = slides[currentSlide - 1];
            const groups = slideData?.animations?.groups || [];
            const group = groups.find(g => g.id === selectedGroupId);

            if (!group) return;

            const index = group.elementIds.indexOf(buildId);

            if (index >= 0) {
                // Element is in group - remove it
                group.elementIds.splice(index, 1);
                console.log(`Removed element ${buildId} from ${selectedGroupId}`);
            } else {
                // Element not in group - add it
                group.elementIds.push(buildId);
                console.log(`Added element ${buildId} to ${selectedGroupId}`);
            }

            // Save and update UI
            saveAnimations(currentSlide - 1);
            renderGroups();
            highlightGroupElements(group);
        }

        // ═══════════════════════════════════════════════════════════════════════
        // DYNAMIC MANIFEST LOADING
        // Attempts to load fresh data from manifest.json (for server deployments)
        // Falls back to injected data if fetch fails (file:// protocol)
        // Also loads animations from localStorage when using file:// protocol
        // ═══════════════════════════════════════════════════════════════════════
        async function loadManifest() {
            let manifestLoaded = false;

            try {
                const cacheBuster = `?t=${Date.now()}`;
                const response = await fetch(`slides/manifest.json${cacheBuster}`);
                if (!response.ok) throw new Error('Manifest not found');
                const manifest = await response.json();

                // Update global state from manifest
                slides = manifest.slides;
                deckName = manifest.deckName;
                totalSlides = manifest.slides.length;

                // Update UI elements
                document.querySelector('.title').textContent = deckName;
                document.querySelector('.deck-badge').textContent = `${totalSlides} Slides`;
                document.querySelector('.presentation-title').textContent = deckName;

                console.log('Loaded slides from manifest.json');
                manifestLoaded = true;
            } catch (error) {
                // fetch() fails with file:// protocol - use fallback data
                if (FALLBACK_SLIDES && FALLBACK_SLIDES.length > 0) {
                    console.log('Using fallback slide data (file:// protocol or manifest unavailable)');
                    manifestLoaded = true;
                } else {
                    // No fallback data available - show error
                    showError('Unable to load slides. Please ensure slides/manifest.json exists.');
                    return false;
                }
            }

            // Load animations from localStorage (merges into slides array)
            // This handles file:// protocol storage and also serves as fallback
            // for http:// when manifest doesn't have animation data
            if (manifestLoaded) {
                loadAnimationsFromLocalStorage();
            }

            return manifestLoaded;
        }

        function showError(message) {
            const grid = document.getElementById('slide-grid');
            grid.innerHTML = `
                <div style="grid-column: 1 / -1; text-align: center; padding: 60px;">
                    <div style="font-size: 48px; margin-bottom: 24px;">⚠️</div>
                    <h2 style="color: var(--amp-lime); margin-bottom: 16px;">Error Loading Slides</h2>
                    <p style="color: var(--amp-light-gray);">${message}</p>
                    <p style="color: var(--amp-light-gray); margin-top: 16px; font-size: 14px;">
                        Run <code style="background: var(--amp-mid-gray); padding: 2px 8px;">node scripts/generate-manifest.js [deck-slug]</code> to generate the manifest.
                    </p>
                </div>
            `;
            // Update header to show error state
            document.querySelector('.deck-badge').textContent = 'Error';
        }

        // ═══════════════════════════════════════════════════════════════════════
        // GALLERY RENDERING
        // ═══════════════════════════════════════════════════════════════════════
        function renderGallery() {
            const grid = document.getElementById('slide-grid');
            grid.innerHTML = '';

            const cacheBuster = `?t=${Date.now()}`;

            slides.forEach((slide, index) => {
                const card = document.createElement('div');
                card.className = 'card';
                card.onclick = () => enterPresentation(index + 1);
                card.innerHTML = `
                    <div class="card-preview">
                        <iframe src="slides/${slide.filename}${cacheBuster}" loading="lazy"></iframe>
                    </div>
                    <div class="card-info">
                        <div class="card-number">Slide ${slide.number}</div>
                        <div class="card-title">${slide.title || 'Slide ' + slide.number}</div>
                    </div>
                `;
                grid.appendChild(card);
            });
        }

        // ═══════════════════════════════════════════════════════════════════════
        // PRESENTATION MODE
        // ═══════════════════════════════════════════════════════════════════════
        const SLIDE_WIDTH = 1920;
        const SLIDE_HEIGHT = 1080;
        const TRANSITION_DURATION = 150; // Half of 300ms total transition

        function calculateScale() {
            const content = document.querySelector('.presentation-main');
            const container = document.querySelector('.slide-container');
            const iframe = document.getElementById('presentation-iframe');

            if (!content || !container || !iframe) return;

            // Get available space (subtract padding)
            const availableWidth = content.clientWidth - 48;
            const availableHeight = content.clientHeight - 48;

            // Calculate scale to fit while maintaining aspect ratio
            const scaleX = availableWidth / SLIDE_WIDTH;
            const scaleY = availableHeight / SLIDE_HEIGHT;
            const scale = Math.min(scaleX, scaleY);

            // Apply scale to iframe (preserve transition class if present)
            const currentTransform = iframe.classList.contains('transitioning') ? 'transitioning' : '';
            iframe.style.transform = `scale(${scale})`;

            // Size container to match scaled dimensions
            container.style.width = `${SLIDE_WIDTH * scale}px`;
            container.style.height = `${SLIDE_HEIGHT * scale}px`;
        }

        // ═══════════════════════════════════════════════════════════════════════
        // SIDEBAR RENDERING
        // ═══════════════════════════════════════════════════════════════════════
        function renderSidebar() {
            const sidebar = document.getElementById('sidebar');
            sidebar.innerHTML = '';

            const cacheBuster = `?t=${Date.now()}`;

            slides.forEach((slide, index) => {
                const item = document.createElement('div');
                item.className = 'sidebar-item' + (index + 1 === currentSlide ? ' active' : '');
                item.onclick = () => goToSlide(index + 1);
                item.innerHTML = `
                    <iframe src="slides/${slide.filename}${cacheBuster}" loading="lazy"></iframe>
                    <span class="sidebar-number">${slide.number}</span>
                `;
                item.id = `sidebar-item-${index + 1}`;
                sidebar.appendChild(item);
            });
        }

        function updateSidebarHighlight() {
            // Remove active from all items
            document.querySelectorAll('.sidebar-item').forEach(item => {
                item.classList.remove('active');
            });
            // Add active to current slide
            const activeItem = document.getElementById(`sidebar-item-${currentSlide}`);
            if (activeItem) {
                activeItem.classList.add('active');
                // Auto-scroll sidebar to keep current slide visible
                activeItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }

        // ═══════════════════════════════════════════════════════════════════════
        // SLIDE TRANSITIONS
        // ═══════════════════════════════════════════════════════════════════════
        function updatePresentationSlideWithTransition() {
            const slide = slides[currentSlide - 1];
            if (!slide) return;

            const iframe = document.getElementById('presentation-iframe');
            const cacheBuster = `?t=${Date.now()}`;

            // Fade out
            iframe.classList.add('transitioning');

            setTimeout(() => {
                if (isFileProtocol() && SLIDE_HTML_BASE64 && SLIDE_HTML_BASE64[currentSlide - 1]) {
                    // Use srcdoc for file:// protocol to avoid cross-origin issues
                    loadSlideWithSrcdoc(iframe, currentSlide - 1, () => {
                        iframe.classList.remove('transitioning');
                        // Initialize build state after slide loads (if in fullscreen)
                        if (isInFullscreen() && !builderMode) {
                            const fullyBuilt = buildState.nextSlideFullyBuilt;
                            buildState.nextSlideFullyBuilt = false; // Reset flag
                            initializeBuildState(currentSlide, fullyBuilt, true);
                        }
                        // Scan elements for builder mode now that slide content is loaded
                        if (builderMode) {
                            scanSlideElements();
                            renderHighlights();
                        }
                        // Attach keyboard forwarder for navigation in fullscreen
                        attachIframeKeyboardForwarder();
                    });
                } else {
                    // Update source while invisible (with cache-busting)
                    iframe.src = `slides/${slide.filename}${cacheBuster}`;

                    // Fade in after src is set (onload for smoother transition)
                    iframe.onload = () => {
                        iframe.classList.remove('transitioning');
                        // Initialize build state after slide loads (if in fullscreen)
                        if (isInFullscreen() && !builderMode) {
                            const fullyBuilt = buildState.nextSlideFullyBuilt;
                            buildState.nextSlideFullyBuilt = false; // Reset flag
                            initializeBuildState(currentSlide, fullyBuilt, true);
                        }
                        // Scan elements for builder mode now that slide content is loaded
                        if (builderMode) {
                            scanSlideElements();
                            renderHighlights();
                        }
                        // Attach keyboard forwarder for navigation in fullscreen
                        attachIframeKeyboardForwarder();
                    };
                }
            }, TRANSITION_DURATION);

            // Update counter and button states
            document.getElementById('slide-counter').textContent = `${currentSlide} / ${totalSlides}`;
            document.getElementById('prev-btn').disabled = currentSlide <= 1;
            document.getElementById('next-btn').disabled = currentSlide >= totalSlides;

            // Update sidebar highlight
            updateSidebarHighlight();
        }

        /**
         * Load slide into iframe using srcdoc (for file:// protocol)
         * This avoids cross-origin issues and allows direct DOM access
         * @param {HTMLIFrameElement} iframe - The iframe element
         * @param {number} slideIndex - 0-indexed slide number
         * @param {Function} onLoad - Callback when loaded
         */
        function loadSlideWithSrcdoc(iframe, slideIndex, onLoad) {
            const binaryString = atob(SLIDE_HTML_BASE64[slideIndex]);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            const htmlContent = new TextDecoder().decode(bytes);

            // Inject build animation CSS into the HTML before setting srcdoc
            const htmlWithBuildCSS = injectBuildCSSIntoHTML(htmlContent);

            iframe.srcdoc = htmlWithBuildCSS;
            iframe.onload = () => {
                // Set up edit handlers for server persistence
                setupSlideEditHandlers(iframe, slideIndex + 1);
                if (onLoad) onLoad();
            };
        }

        /**
         * Inject build animation CSS AND command handler into slide HTML content
         * The command handler listens for postMessage build commands
         * @param {string} htmlContent - The slide HTML
         * @returns {string} HTML with build CSS and handler injected
         */
        function injectBuildCSSIntoHTML(htmlContent) {
            const buildCSSAndHandler = `
                <style id="build-animation-styles">
                    [data-build-id].build-hidden {
                        opacity: 0 !important;
                        visibility: hidden !important;
                    }
                    [data-build-id].build-revealing {
                        animation: buildFadeIn 0.4s ease-out forwards;
                    }
                    [data-build-id].build-visible {
                        opacity: 1;
                        visibility: visible;
                    }
                    @keyframes buildFadeIn {
                        from { opacity: 0; transform: translateY(10px); }
                        to { opacity: 1; transform: translateY(0); }
                    }
                </style>
                <script id="build-command-handler">
                (function() {
                    // Assign data-build-id to elements on page load
                    // This ensures elements can be found for animation playback
                    function assignBuildIds() {
                        var selectors = '[data-animatable], [contenteditable], h1, h2, h3, p, li, img, svg, [class*="-box"], [class*="-card"], [class*="-panel"], [class*="-window"], [class*="-item"], [class*="-block"]';
                        var idCounter = 1;
                        document.querySelectorAll(selectors).forEach(function(el) {
                            var rect = el.getBoundingClientRect();
                            if (rect.width < 10 || rect.height < 10) return;
                            if (rect.width > 1536 || rect.height > 864) return;
                            if (!el.getAttribute('data-build-id')) {
                                el.setAttribute('data-build-id', 'build-' + idCounter++);
                            }
                        });
                    }

                    // Run on DOM ready
                    if (document.readyState === 'loading') {
                        document.addEventListener('DOMContentLoaded', assignBuildIds);
                    } else {
                        assignBuildIds();
                    }

                    window.addEventListener('message', function(event) {
                        if (!event.data || !event.data.type) return;

                        if (event.data.type === 'buildHideElements') {
                            (event.data.elementIds || []).forEach(function(id) {
                                var el = document.querySelector('[data-build-id="' + id + '"]');
                                if (el) {
                                    el.classList.remove('build-visible', 'build-revealing');
                                    el.classList.add('build-hidden');
                                }
                            });
                        }
                        else if (event.data.type === 'buildRevealElements') {
                            (event.data.elementIds || []).forEach(function(id) {
                                var el = document.querySelector('[data-build-id="' + id + '"]');
                                if (el) {
                                    el.classList.remove('build-hidden', 'build-visible');
                                    el.classList.add('build-revealing');
                                    setTimeout(function() {
                                        el.classList.remove('build-revealing');
                                        el.classList.add('build-visible');
                                    }, 400);
                                }
                            });
                        }
                        else if (event.data.type === 'buildShowAll') {
                            // Show all build elements
                            document.querySelectorAll('[data-build-id]').forEach(function(el) {
                                el.classList.remove('build-hidden', 'build-revealing');
                                el.classList.add('build-visible');
                            });
                        }
                    });
                })();
                <\/script>
            `;

            // Inject before </body> to ensure DOM is ready
            if (htmlContent.includes('</body>')) {
                return htmlContent.replace('</body>', buildCSSAndHandler + '</body>');
            } else if (htmlContent.includes('</head>')) {
                return htmlContent.replace('</head>', buildCSSAndHandler + '</head>');
            }
            return htmlContent + buildCSSAndHandler;
        }

        function enterPresentation(slideNumber) {
            currentSlide = slideNumber;
            document.getElementById('gallery-view').classList.add('hidden');
            document.getElementById('presentation-view').classList.remove('hidden');

            // Render sidebar
            renderSidebar();

            // Initial slide load (no transition needed for first load)
            const slide = slides[currentSlide - 1];
            if (slide) {
                const iframe = document.getElementById('presentation-iframe');
                if (isFileProtocol() && SLIDE_HTML_BASE64 && SLIDE_HTML_BASE64[currentSlide - 1]) {
                    // Use srcdoc for file:// protocol to avoid cross-origin issues
                    loadSlideWithSrcdoc(iframe, currentSlide - 1, null);
                } else {
                    const cacheBuster = `?t=${Date.now()}`;
                    iframe.src = `slides/${slide.filename}${cacheBuster}`;
                }
                document.getElementById('slide-counter').textContent = `${currentSlide} / ${totalSlides}`;
                document.getElementById('prev-btn').disabled = currentSlide <= 1;
                document.getElementById('next-btn').disabled = currentSlide >= totalSlides;
            }

            // Recalculate scale after showing presentation view
            setTimeout(calculateScale, 10);
        }

        function exitToGallery() {
            // Exit builder mode first if active
            if (builderMode) {
                exitAnimationBuilder();
            }
            // Exit fullscreen first if active
            if (document.fullscreenElement || document.webkitFullscreenElement) {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                }
            }
            document.getElementById('presentation-view').classList.add('hidden');
            document.getElementById('gallery-view').classList.remove('hidden');
        }

        function updatePresentationSlide() {
            // Use transition version
            updatePresentationSlideWithTransition();
        }

        // Recalculate scale on window resize
        window.addEventListener('resize', () => {
            if (!document.getElementById('presentation-view').classList.contains('hidden')) {
                calculateScale();
            }
        });

        // ═══════════════════════════════════════════════════════════════════════
        // NAVIGATION FUNCTIONS
        // ═══════════════════════════════════════════════════════════════════════
        function nextSlide() {
            if (currentSlide < totalSlides) {
                currentSlide++;
                updatePresentationSlide();
                if (builderMode) {
                    refreshBuilderForCurrentSlide();
                }
            }
        }

        function prevSlide() {
            if (currentSlide > 1) {
                currentSlide--;
                updatePresentationSlide();
                if (builderMode) {
                    refreshBuilderForCurrentSlide();
                }
            }
        }

        /**
         * Refresh the animation builder for the current slide
         * Called when navigating slides while in builder mode
         */
        function refreshBuilderForCurrentSlide() {
            // Clear selection state including group selection
            selectedGroupId = null;
            selectedElements.clear();
            builderElements = [];
            hoveredElementId = null;

            // Clear any group highlights from the previous slide
            clearGroupHighlights();

            // Render groups immediately (they come from manifest, already correct)
            renderGroups();
            renderHighlights();
            updateSelectionCount();
            updateCreateGroupButton();

            // NOTE: scanSlideElements() is called by iframe onload in
            // updatePresentationSlideWithTransition() after slide actually loads
        }

        function goToSlide(n) {
            if (n >= 1 && n <= totalSlides && n !== currentSlide) {
                // Exit builder mode when changing slides
                if (builderMode) {
                    exitAnimationBuilder();
                }
                currentSlide = n;
                updatePresentationSlide();
            }
        }

        // ═══════════════════════════════════════════════════════════════════════
        // FULLSCREEN SUPPORT
        // ═══════════════════════════════════════════════════════════════════════
        function toggleFullscreen() {
            const viewer = document.getElementById('presentation-view');

            if (!document.fullscreenElement && !document.webkitFullscreenElement) {
                // Enter fullscreen
                if (viewer.requestFullscreen) {
                    viewer.requestFullscreen();
                } else if (viewer.webkitRequestFullscreen) {
                    viewer.webkitRequestFullscreen();
                } else if (viewer.msRequestFullscreen) {
                    viewer.msRequestFullscreen();
                }
            } else {
                // Exit fullscreen
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
        }

        // Recalculate scale and handle build state when fullscreen changes
        document.addEventListener('fullscreenchange', () => {
            setTimeout(calculateScale, 50);
            // Handle build state for fullscreen transitions
            if (isInFullscreen()) {
                onFullscreenEnter();
            } else {
                onFullscreenExit();
            }
        });
        document.addEventListener('webkitfullscreenchange', () => {
            setTimeout(calculateScale, 50);
            // Handle build state for fullscreen transitions
            if (isInFullscreen()) {
                onFullscreenEnter();
            } else {
                onFullscreenExit();
            }
        });

        // ═══════════════════════════════════════════════════════════════════════
        // DOWNLOAD MENU
        // ═══════════════════════════════════════════════════════════════════════
        function toggleDownloadMenu(event) {
            if (event) {
                event.stopPropagation();
            }
            const menu = document.getElementById('download-menu');
            menu.classList.toggle('hidden');
        }

        function closeDownloadMenu() {
            const menu = document.getElementById('download-menu');
            if (menu && !menu.classList.contains('hidden')) {
                menu.classList.add('hidden');
            }
        }

        // Click outside handler to close menu
        document.addEventListener('click', (e) => {
            const menu = document.getElementById('download-menu');
            const wrapper = e.target.closest('.download-wrapper');
            if (!wrapper && menu && !menu.classList.contains('hidden')) {
                menu.classList.add('hidden');
            }
        });

        // ═══════════════════════════════════════════════════════════════════════
        // SLIDE EXPORT FUNCTIONS
        // ═══════════════════════════════════════════════════════════════════════

        /**
         * Sanitize a string to be used as a filename
         * Replaces non-alphanumeric characters with hyphens
         */
        function sanitizeFilename(name) {
            return name.replace(/[^a-z0-9]/gi, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
        }

        /**
         * Download a blob as a file
         * @param {Blob} blob - The blob to download
         * @param {string} filename - The filename for the download
         */
        function downloadBlob(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        /**
         * Capture the current slide as a canvas using html2canvas
         * Uses embedded HTML content for file:// protocol support
         * @returns {Promise<HTMLCanvasElement>} The rendered canvas
         */
        async function captureSlide() {
            const slide = slides[currentSlide - 1];
            if (!slide) {
                throw new Error('Current slide not found');
            }

            // For http(s):// protocol, try direct iframe access (faster)
            // For file:// protocol, skip directly to blob URL fallback (avoids CORS errors)
            const isFileProtocol = window.location.protocol === 'file:';

            if (!isFileProtocol) {
                const presentationIframe = document.getElementById('presentation-iframe');
                try {
                    const slideDoc = presentationIframe.contentDocument || presentationIframe.contentWindow.document;
                    const slideElement = slideDoc.querySelector('.slide');
                    if (slideElement) {
                        // Direct access works - use it (fastest method)
                        const canvas = await html2canvas(slideElement, {
                            width: SLIDE_WIDTH,
                            height: SLIDE_HEIGHT,
                            scale: 1,
                            useCORS: true,
                            allowTaint: true,
                            backgroundColor: null,
                            logging: false
                        });
                        return canvas;
                    }
                } catch (e) {
                    console.log('Direct iframe access failed, using embedded HTML fallback');
                }
            }

            // Use srcdoc fallback: embeds HTML directly in iframe (no URL, no CORS)
            const slideIndex = currentSlide - 1;
            if (!SLIDE_HTML_BASE64 || !SLIDE_HTML_BASE64[slideIndex]) {
                throw new Error('Slide HTML content not embedded. Please regenerate the viewer.');
            }

            // Decode base64 HTML content (proper UTF-8 handling)
            const binaryString = atob(SLIDE_HTML_BASE64[slideIndex]);
            const bytes = Uint8Array.from(binaryString, c => c.charCodeAt(0));
            const htmlContent = new TextDecoder('utf-8').decode(bytes);

            // Create hidden container
            const container = document.createElement('div');
            container.style.cssText = 'position:fixed;left:-9999px;top:0;width:1920px;height:1080px;overflow:hidden;';
            document.body.appendChild(container);

            // Create iframe with srcdoc (direct HTML embedding - no origin/CORS issues)
            const captureFrame = document.createElement('iframe');
            captureFrame.style.cssText = 'width:1920px;height:1080px;border:none;';
            container.appendChild(captureFrame);

            try {
                // Use srcdoc to embed HTML directly (avoids all cross-origin issues)
                await new Promise((resolve, reject) => {
                    captureFrame.onload = resolve;
                    captureFrame.onerror = reject;
                    captureFrame.srcdoc = htmlContent;
                });

                // Access the iframe document (same-origin via srcdoc)
                const slideDoc = captureFrame.contentDocument;

                // Inject CSS to disable animations and force final state for capture
                // NOTE: Do NOT override transform - it's used for layout (e.g., translateY(-50%) for vertical centering)
                const captureStyles = slideDoc.createElement('style');
                captureStyles.textContent = `
                    *, *::before, *::after {
                        animation: none !important;
                        animation-delay: 0s !important;
                        animation-fill-mode: none !important;
                        transition: none !important;
                        opacity: 1 !important;
                        visibility: visible !important;
                    }
                `;
                slideDoc.head.appendChild(captureStyles);

                // Wait for fonts to load (Google Fonts may take time)
                await new Promise(resolve => setTimeout(resolve, 500));

                const slideElement = slideDoc.querySelector('.slide');

                if (!slideElement) {
                    throw new Error('Slide element not found in captured content');
                }

                // Capture with html2canvas
                const canvas = await html2canvas(slideElement, {
                    width: SLIDE_WIDTH,
                    height: SLIDE_HEIGHT,
                    scale: 1,
                    useCORS: true,
                    allowTaint: true,
                    backgroundColor: null,
                    logging: false
                });

                return canvas;
            } finally {
                // Clean up
                document.body.removeChild(container);
            }
        }

        /**
         * Download the current slide as a PNG image
         */
        async function downloadCurrentSlide() {
            closeDownloadMenu();

            try {
                // Capture the slide
                const canvas = await captureSlide();

                // Convert canvas to PNG blob
                canvas.toBlob((blob) => {
                    if (!blob) {
                        console.error('Failed to create PNG blob');
                        alert('Failed to create PNG image');
                        return;
                    }

                    // Generate filename: {deckName}-slide-{N}.png
                    const safeDeckName = sanitizeFilename(deckName);
                    const filename = `${safeDeckName}-slide-${currentSlide}.png`;

                    // Trigger download
                    downloadBlob(blob, filename);

                    console.log(`Downloaded: ${filename}`);
                }, 'image/png');
            } catch (error) {
                console.error('Error capturing slide:', error);
                alert('Error capturing slide: ' + error.message);
            }
        }

        // ═══════════════════════════════════════════════════════════════════════
        // PROGRESS MODAL FUNCTIONS
        // ═══════════════════════════════════════════════════════════════════════

        /**
         * Show the progress modal with a title
         * @param {string} title - The title to display
         */
        function showProgressModal(title) {
            const modal = document.getElementById('progress-modal');
            const titleEl = document.getElementById('progress-title');
            const progressBar = document.getElementById('progress-bar');
            const progressText = document.getElementById('progress-text');

            titleEl.textContent = title;
            progressBar.style.width = '0%';
            progressText.textContent = 'Initializing...';
            modal.classList.remove('hidden');
        }

        /**
         * Update the progress bar and text
         * @param {number} current - Current slide number
         * @param {number} total - Total slides
         */
        function updateProgress(current, total) {
            const progressBar = document.getElementById('progress-bar');
            const progressText = document.getElementById('progress-text');

            const percent = Math.round((current / total) * 100);
            progressBar.style.width = `${percent}%`;
            progressText.textContent = `Processing slide ${current} of ${total}...`;
        }

        /**
         * Hide the progress modal
         */
        function hideProgressModal() {
            const modal = document.getElementById('progress-modal');
            modal.classList.add('hidden');
        }

        /**
         * Capture a specific slide as a PNG blob (for batch export)
         * @param {number} slideIndex - Zero-based slide index
         * @returns {Promise<Blob>} PNG blob of the slide
         */
        async function captureSlideForExport(slideIndex) {
            const slide = slides[slideIndex];
            if (!slide) {
                throw new Error(`Slide at index ${slideIndex} not found`);
            }

            // For http(s):// protocol, try direct iframe access (faster)
            // For file:// protocol, skip directly to blob URL fallback (avoids CORS errors)
            const isFileProtocol = window.location.protocol === 'file:';

            if (!isFileProtocol) {
                // Create temporary iframe for this slide
                const container = document.createElement('div');
                container.style.cssText = 'position:fixed;left:-9999px;top:0;width:1920px;height:1080px;overflow:hidden;';
                document.body.appendChild(container);

                const tempFrame = document.createElement('iframe');
                tempFrame.style.cssText = 'width:1920px;height:1080px;border:none;';
                container.appendChild(tempFrame);

                try {
                    // Load slide via src
                    await new Promise((resolve, reject) => {
                        tempFrame.onload = resolve;
                        tempFrame.onerror = reject;
                        tempFrame.src = `slides/${slide.filename}`;
                    });

                    const slideDoc = tempFrame.contentDocument || tempFrame.contentWindow.document;
                    const slideElement = slideDoc.querySelector('.slide');

                    if (slideElement) {
                        const canvas = await html2canvas(slideElement, {
                            width: SLIDE_WIDTH,
                            height: SLIDE_HEIGHT,
                            scale: 1,
                            useCORS: true,
                            allowTaint: true,
                            backgroundColor: null,
                            logging: false
                        });

                        return new Promise((resolve, reject) => {
                            canvas.toBlob((blob) => {
                                if (blob) resolve(blob);
                                else reject(new Error('Failed to create blob'));
                            }, 'image/png');
                        });
                    }
                } catch (e) {
                    console.log('Direct iframe access failed, using embedded HTML fallback');
                } finally {
                    document.body.removeChild(container);
                }
            }

            // Use srcdoc fallback: embeds HTML directly in iframe (no URL, no CORS)
            if (!SLIDE_HTML_BASE64 || !SLIDE_HTML_BASE64[slideIndex]) {
                throw new Error('Slide HTML content not embedded. Please regenerate the viewer.');
            }

            // Decode base64 HTML content (proper UTF-8 handling)
            const binaryString = atob(SLIDE_HTML_BASE64[slideIndex]);
            const bytes = Uint8Array.from(binaryString, c => c.charCodeAt(0));
            const htmlContent = new TextDecoder('utf-8').decode(bytes);

            // Create hidden container
            const container = document.createElement('div');
            container.style.cssText = 'position:fixed;left:-9999px;top:0;width:1920px;height:1080px;overflow:hidden;';
            document.body.appendChild(container);

            // Create iframe with srcdoc (direct HTML embedding - no origin/CORS issues)
            const captureFrame = document.createElement('iframe');
            captureFrame.style.cssText = 'width:1920px;height:1080px;border:none;';
            container.appendChild(captureFrame);

            try {
                // Use srcdoc to embed HTML directly (avoids all cross-origin issues)
                await new Promise((resolve, reject) => {
                    captureFrame.onload = resolve;
                    captureFrame.onerror = reject;
                    captureFrame.srcdoc = htmlContent;
                });

                // Access the iframe document (same-origin via srcdoc)
                const slideDoc = captureFrame.contentDocument;

                // Inject CSS to disable animations and force final state for capture
                // NOTE: Do NOT override transform - it's used for layout (e.g., translateY(-50%) for vertical centering)
                const captureStyles = slideDoc.createElement('style');
                captureStyles.textContent = `
                    *, *::before, *::after {
                        animation: none !important;
                        animation-delay: 0s !important;
                        animation-fill-mode: none !important;
                        transition: none !important;
                        opacity: 1 !important;
                        visibility: visible !important;
                    }
                `;
                slideDoc.head.appendChild(captureStyles);

                // Wait for fonts to load (Google Fonts may take time)
                await new Promise(resolve => setTimeout(resolve, 300));

                const slideElement = slideDoc.querySelector('.slide');

                if (!slideElement) {
                    throw new Error('Slide element not found in captured content');
                }

                // Capture with html2canvas
                const canvas = await html2canvas(slideElement, {
                    width: SLIDE_WIDTH,
                    height: SLIDE_HEIGHT,
                    scale: 1,
                    useCORS: true,
                    allowTaint: true,
                    backgroundColor: null,
                    logging: false
                });

                // Convert to blob
                return new Promise((resolve, reject) => {
                    canvas.toBlob((blob) => {
                        if (blob) resolve(blob);
                        else reject(new Error('Failed to create PNG blob'));
                    }, 'image/png');
                });
            } finally {
                // Clean up
                document.body.removeChild(container);
            }
        }

        /**
         * Download all slides as a ZIP file containing PNGs
         */
        async function downloadAllSlidesPNG() {
            closeDownloadMenu();

            try {
                showProgressModal('Exporting slides as PNG...');

                const zip = new JSZip();
                const total = totalSlides;

                // Process slides sequentially to manage memory
                for (let i = 0; i < total; i++) {
                    updateProgress(i + 1, total);

                    // Capture slide as PNG blob
                    const blob = await captureSlideForExport(i);

                    // Add to ZIP with numbered filename
                    zip.file(`slide-${i + 1}.png`, blob);

                    // Small delay between slides to prevent UI freezing
                    await new Promise(resolve => setTimeout(resolve, 50));
                }

                // Generate ZIP file
                updateProgress(total, total);
                const zipBlob = await zip.generateAsync({
                    type: 'blob',
                    compression: 'DEFLATE',
                    compressionOptions: { level: 6 }
                });

                // Download the ZIP
                const safeDeckName = sanitizeFilename(deckName);
                downloadBlob(zipBlob, `${safeDeckName}-slides.zip`);

                console.log(`Downloaded: ${safeDeckName}-slides.zip with ${total} slides`);
            } catch (error) {
                console.error('Error creating ZIP:', error);
                alert('Error creating ZIP file: ' + error.message);
            } finally {
                hideProgressModal();
            }
        }

        /**
         * Download entire deck as a single PDF file
         * Each slide becomes a separate page at 1920x1080 landscape
         */
        async function downloadDeckPDF() {
            closeDownloadMenu();

            try {
                showProgressModal('Generating PDF...');

                // Initialize jsPDF with custom page size matching slides
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF({
                    orientation: 'landscape',
                    unit: 'px',
                    format: [SLIDE_WIDTH, SLIDE_HEIGHT],
                    hotfixes: ['px_scaling']
                });

                const total = totalSlides;

                // Process slides sequentially to manage memory
                for (let i = 0; i < total; i++) {
                    updateProgress(i + 1, total);

                    // Add new page for slides after the first
                    if (i > 0) {
                        pdf.addPage([SLIDE_WIDTH, SLIDE_HEIGHT], 'landscape');
                    }

                    // Capture slide as PNG blob
                    const blob = await captureSlideForExport(i);

                    // Convert blob to data URL for jsPDF
                    const dataUrl = await new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onloadend = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsDataURL(blob);
                    });

                    // Add image to current PDF page (full page coverage)
                    pdf.addImage(dataUrl, 'PNG', 0, 0, SLIDE_WIDTH, SLIDE_HEIGHT);

                    // Small delay between slides to prevent UI freezing
                    await new Promise(resolve => setTimeout(resolve, 50));
                }

                // Save the PDF
                const safeDeckName = sanitizeFilename(deckName);
                pdf.save(`${safeDeckName}.pdf`);

                console.log(`Downloaded: ${safeDeckName}.pdf with ${total} slides`);
            } catch (error) {
                console.error('Error creating PDF:', error);
                alert('Error creating PDF file: ' + error.message);
            } finally {
                hideProgressModal();
            }
        }

        // ═══════════════════════════════════════════════════════════════════════
        // IFRAME KEYBOARD FORWARDING
        // ═══════════════════════════════════════════════════════════════════════
        /**
         * Check if the keyboard event target is an editable text element.
         * Used to prevent navigation shortcuts from firing during text editing.
         */
        function isEditingText(e) {
            const target = e.target;
            const tagName = target.tagName;
            if (tagName === 'INPUT' || tagName === 'TEXTAREA' || tagName === 'SELECT') {
                return true;
            }
            if (target.isContentEditable) {
                return true;
            }
            return false;
        }

        /**
         * Attach keyboard listener to iframe document to forward navigation keys
         * This ensures arrow keys work for slide navigation even when iframe has focus
         */
        function attachIframeKeyboardForwarder() {
            const iframe = document.getElementById('presentation-iframe');
            if (!iframe) return;

            try {
                const iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                if (!iframeDoc) return;

                // Remove existing listener if any (to avoid duplicates)
                iframeDoc.removeEventListener('keydown', iframeKeyHandler);
                iframeDoc.addEventListener('keydown', iframeKeyHandler);
            } catch (e) {
                // Cross-origin iframe, can't attach listener
                console.log('Cannot attach keyboard forwarder to iframe (cross-origin)');
            }
        }

        /**
         * Handle keyboard events from within the iframe
         * Directly call navigation functions instead of dispatching events
         */
        function iframeKeyHandler(e) {
            // Skip if in builder mode (let builder handle keys)
            if (builderMode) return;
            // Skip if user is editing text in a contenteditable or form field
            if (isEditingText(e)) return;

            switch(e.key) {
                case 'ArrowRight':
                case 'ArrowDown':
                case ' ':
                    e.preventDefault();
                    advanceBuild();
                    break;
                case 'ArrowLeft':
                case 'ArrowUp':
                    e.preventDefault();
                    reverseBuild();
                    break;
                case 'Escape':
                    e.preventDefault();
                    if (document.fullscreenElement || document.webkitFullscreenElement) {
                        if (document.exitFullscreen) {
                            document.exitFullscreen();
                        } else if (document.webkitExitFullscreen) {
                            document.webkitExitFullscreen();
                        }
                    } else {
                        exitToGallery();
                    }
                    break;
                case 'f':
                case 'F':
                    e.preventDefault();
                    toggleFullscreen();
                    break;
                case 'Home':
                    e.preventDefault();
                    goToSlide(1);
                    break;
                case 'End':
                    e.preventDefault();
                    goToSlide(totalSlides);
                    break;
                default:
                    if (e.key >= '1' && e.key <= '9') {
                        e.preventDefault();
                        const num = parseInt(e.key);
                        if (num <= totalSlides) {
                            goToSlide(num);
                        }
                    }
            }
        }

        // ═══════════════════════════════════════════════════════════════════════
        // KEYBOARD NAVIGATION
        // ═══════════════════════════════════════════════════════════════════════
        document.addEventListener('keydown', (e) => {
            // Only handle keys in presentation mode
            if (document.getElementById('presentation-view').classList.contains('hidden')) {
                return;
            }
            // Skip if user is editing text in a contenteditable or form field
            if (isEditingText(e)) return;

            switch(e.key) {
                case 'ArrowRight':
                case 'ArrowDown':
                case ' ':
                    // Don't navigate if in builder mode
                    if (builderMode) return;
                    e.preventDefault();
                    // Use advanceBuild for fullscreen build progression
                    advanceBuild();
                    break;
                case 'ArrowLeft':
                case 'ArrowUp':
                    // Don't navigate if in builder mode
                    if (builderMode) return;
                    e.preventDefault();
                    // Use reverseBuild for fullscreen build regression
                    reverseBuild();
                    break;
                case 'Escape':
                    e.preventDefault();
                    // If in builder mode with a group selected, deselect group first
                    if (builderMode && selectedGroupId) {
                        deselectGroup();
                        return;
                    }
                    // If in builder mode (no group selected), exit builder
                    if (builderMode) {
                        exitAnimationBuilder();
                        return;
                    }
                    // If in fullscreen, exit fullscreen first (stay in presentation)
                    if (document.fullscreenElement || document.webkitFullscreenElement) {
                        if (document.exitFullscreen) {
                            document.exitFullscreen();
                        } else if (document.webkitExitFullscreen) {
                            document.webkitExitFullscreen();
                        }
                    } else {
                        // Not in fullscreen, exit to gallery
                        exitToGallery();
                    }
                    break;
                case 'f':
                case 'F':
                    // Don't toggle fullscreen if in builder mode
                    if (builderMode) return;
                    e.preventDefault();
                    toggleFullscreen();
                    break;
                case 'd':
                case 'D':
                    // Don't open download menu if in builder mode
                    if (builderMode) return;
                    e.preventDefault();
                    toggleDownloadMenu();
                    break;
                case 'b':
                case 'B':
                    e.preventDefault();
                    toggleAnimationBuilder();
                    break;
                case 'Home':
                    if (builderMode) return;
                    e.preventDefault();
                    goToSlide(1);
                    break;
                case 'End':
                    if (builderMode) return;
                    e.preventDefault();
                    goToSlide(totalSlides);
                    break;
                default:
                    // Number keys 1-9 jump to that slide
                    if (builderMode) return;
                    if (e.key >= '1' && e.key <= '9') {
                        e.preventDefault();
                        const num = parseInt(e.key);
                        if (num <= totalSlides) {
                            goToSlide(num);
                        }
                    }
            }
        });

        // ═══════════════════════════════════════════════════════════════════════
        // INITIALIZATION
        // ═══════════════════════════════════════════════════════════════════════
        document.addEventListener('DOMContentLoaded', async () => {
            // Check server connection for slide persistence
            checkServerConnection();
            // Periodically re-check connection (every 30 seconds)
            setInterval(checkServerConnection, 30000);

            const loaded = await loadManifest();
            if (loaded) {
                renderGallery();
            }
        });
    </script>
</body>
</html>
