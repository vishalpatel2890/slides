/**
 * Claude Context Writer - Generates structured markdown context for Claude Code.
 *
 * Story Reference: 23-1 Claude Code Context Injection
 * Architecture Reference: notes/architecture/architecture.md#Pattern 3: Hybrid Edit Model
 *
 * This module provides context injection so Claude Code has full awareness of
 * the deck structure when the Plan Editor is open. The context file is written
 * to .slide-builder/plan-editor-context.md in the workspace root.
 *
 * ## Context File Lifecycle
 * - Written on Plan Editor activation (handleReady)
 * - Updated when plan changes (debounced, same cycle as plan-updated sync)
 * - Deleted when Plan Editor panel is disposed (cleanup)
 *
 * ## Design Decisions
 * - generateContextMarkdown() is a pure function for testability (AC-23.1.17)
 * - Uses getSlideIntent/getSlideTemplate/getSlideVisualGuidance for backward compat (AC-23.1.18)
 * - File I/O uses workspace.fs API (AC-23.1.15)
 * - Errors logged to output channel, not surfaced to user (AC-23.1.16)
 */

import * as vscode from 'vscode';
import type {
  PlanData,
  SlideEntry,
  TemplateCatalogEntry,
  ThemeConfig,
  AgendaSection,
} from '../shared/types';
import {
  getSlideIntent,
  getSlideTemplate,
  getSlideVisualGuidance,
  getAgendaSections,
} from '../shared/types';

// =============================================================================
// Types
// =============================================================================

/**
 * Options for generating Claude Code context markdown.
 * AC-23.1.17: Interface allows generateContextMarkdown to be a pure function.
 */
export interface ClaudeContextOptions {
  plan: PlanData;
  templates: TemplateCatalogEntry[];
  theme: ThemeConfig | null;
  focusedSlide?: SlideEntry;
  focusedSlideNeighbors?: { previous?: SlideEntry; next?: SlideEntry };
  /** User instruction from the Edit with Claude dialog */
  instruction?: string;
  /** AC #14: When true, output only deck name, purpose, audience, and plan editing workflows */
  minimal?: boolean;
}

// =============================================================================
// Context File Path Constants
// =============================================================================

const CONTEXT_DIR = '.slide-builder';
const CONTEXT_FILENAME = 'plan-editor-context.md';

// =============================================================================
// Pure Generation Function
// =============================================================================

/**
 * Generates the markdown content for the Claude Code context file.
 * This is a pure function with no side effects — it only transforms data.
 *
 * AC-23.1.17: Pure function for independent unit testing.
 * AC-23.1.18: Uses helper functions for backward-compatible field access.
 *
 * @param options - The context generation options
 * @returns Complete markdown string for the context file
 */
export function generateContextMarkdown(options: ClaudeContextOptions): string {
  const { plan, templates, theme, focusedSlide, focusedSlideNeighbors, instruction, minimal } = options;
  const timestamp = new Date().toISOString();

  const sections: string[] = [];

  // Header comment (AC-23.1.10)
  sections.push(
    `<!-- AUTO-GENERATED by Slide Builder Plan Editor — do not edit manually -->`,
    `<!-- Updated: ${timestamp} -->`,
    ''
  );

  // Title
  sections.push('# Plan Editor Context', '');

  // User instruction (from Edit with Claude dialog)
  if (instruction) {
    sections.push(
      '## User Request',
      '',
      `> ${instruction}`,
      ''
    );
  }

  // Deck Overview (AC-23.1.2, AC-23.1.3) - always included
  sections.push(generateDeckOverview(plan));

  // AC #14: Minimal mode — only deck overview + plan editing workflows
  if (minimal) {
    sections.push(generateEditingInstructions());
    sections.push(generatePlanEditingWorkflows());
    return sections.join('\n');
  }

  // Full context mode (AC #15: slide-specific or initial context)

  // Storyline (AC-23.1.6)
  sections.push(generateStoryline(plan));

  // Agenda Sections (AC-23.1.4)
  sections.push(generateAgendaSections(plan));

  // Slides (AC-23.1.5)
  sections.push(generateSlidesTable(plan));

  // Available Templates (AC-23.1.7)
  sections.push(generateTemplatesSection(templates));

  // Theme (AC-23.1.8)
  sections.push(generateThemeSection(theme));

  // Editing Instructions (AC-23.1.9)
  sections.push(generateEditingInstructions());

  // Focused Slide Section (only when "Edit with Claude" is clicked from slide)
  // OR Workflow Recommendations (when "Edit with Claude" is clicked from plan-level TopBar)
  if (focusedSlide) {
    sections.push(generateFocusedSlideSection(focusedSlide, focusedSlideNeighbors, plan));
  } else {
    sections.push(generatePlanEditingWorkflows());
  }

  return sections.join('\n');
}

// =============================================================================
// Section Generators (Internal Pure Functions)
// =============================================================================

/**
 * Generates the Deck Overview section.
 * AC-23.1.2: Contains deck name and purpose.
 * AC-23.1.3: Contains audience description and knowledge level.
 */
function generateDeckOverview(plan: PlanData): string {
  const audience = plan.audience || { description: '', knowledge_level: 'intermediate', priorities: [] };
  const priorities = audience.priorities?.join(', ') || '';

  return [
    '## Deck Overview',
    '',
    `- **Name:** ${plan.deck_name || '(untitled)'}`,
    `- **Purpose:** ${plan.purpose || ''}`,
    `- **Desired Outcome:** ${plan.desired_outcome || ''}`,
    `- **Key Message:** ${plan.key_message || ''}`,
    `- **Audience:** ${audience.description || ''} (knowledge: ${audience.knowledge_level || 'intermediate'})`,
    priorities ? `- **Priorities:** ${priorities}` : '',
    '',
  ].filter(line => line !== '').join('\n');
}

/**
 * Generates the Storyline section.
 * AC-23.1.6: Contains opening_hook, tension, resolution, call_to_action.
 */
function generateStoryline(plan: PlanData): string {
  const storyline = plan.storyline || { opening_hook: '', tension: '', resolution: '', call_to_action: '' };

  return [
    '## Storyline',
    '',
    `- **Opening Hook:** ${storyline.opening_hook || ''}`,
    `- **Tension:** ${storyline.tension || ''}`,
    `- **Resolution:** ${storyline.resolution || ''}`,
    `- **Call to Action:** ${storyline.call_to_action || ''}`,
    '',
  ].join('\n');
}

/**
 * Generates the Agenda Sections table.
 * AC-23.1.4: Contains all sections with IDs, titles, narrative roles.
 */
function generateAgendaSections(plan: PlanData): string {
  const sections = getAgendaSections(plan);

  if (sections.length === 0) {
    return [
      '## Agenda Sections',
      '',
      'No agenda sections defined.',
      '',
    ].join('\n');
  }

  const rows = sections.map((section: AgendaSection) =>
    `| ${section.id || ''} | ${section.title || ''} | ${section.narrative_role || ''} |`
  );

  return [
    '## Agenda Sections',
    '',
    '| ID | Title | Narrative Role |',
    '|---|---|---|',
    ...rows,
    '',
  ].join('\n');
}

/**
 * Generates the Slides table.
 * AC-23.1.5: Contains numbers, descriptions, templates, status, roles, section IDs.
 * AC-23.1.18: Uses getSlideIntent() for backward-compatible field access.
 */
function generateSlidesTable(plan: PlanData): string {
  const slides = plan.slides || [];

  if (slides.length === 0) {
    return [
      '## Slides',
      '',
      'No slides in this deck.',
      '',
    ].join('\n');
  }

  const rows = slides.map((slide: SlideEntry) => {
    const description = getSlideIntent(slide);
    const template = getSlideTemplate(slide);
    return `| ${slide.number || ''} | ${escapeTableCell(description)} | ${escapeTableCell(template)} | ${slide.status || ''} | ${slide.storyline_role || ''} | ${slide.agenda_section_id || ''} |`;
  });

  return [
    '## Slides',
    '',
    '| # | Description | Template | Status | Role | Section |',
    '|---|---|---|---|---|---|',
    ...rows,
    '',
  ].join('\n');
}

/**
 * Generates the Available Templates section.
 * AC-23.1.7: Contains template names and descriptions from loaded catalog.
 */
function generateTemplatesSection(templates: TemplateCatalogEntry[]): string {
  if (!templates || templates.length === 0) {
    return [
      '## Available Templates',
      '',
      'No templates loaded.',
      '',
    ].join('\n');
  }

  const rows = templates.map((template) => {
    const useCases = template.use_cases?.join(', ') || '';
    return `| ${escapeTableCell(template.name || '')} | ${escapeTableCell(template.description || '')} | ${escapeTableCell(useCases)} |`;
  });

  return [
    '## Available Templates',
    '',
    '| Name | Description | Use Cases |',
    '|---|---|---|',
    ...rows,
    '',
  ].join('\n');
}

/**
 * Generates the Theme section.
 * AC-23.1.8: Contains theme summary or "No theme loaded" placeholder.
 */
function generateThemeSection(theme: ThemeConfig | null): string {
  if (!theme) {
    return [
      '## Theme',
      '',
      'No theme loaded.',
      '',
    ].join('\n');
  }

  // Generate a summary of theme properties
  const summaryLines: string[] = ['## Theme', ''];

  if (theme.colors) {
    const colorCount = Object.keys(theme.colors).length;
    const colorSample = Object.entries(theme.colors).slice(0, 3)
      .map(([name, value]) => `${name}: ${value}`).join(', ');
    summaryLines.push(`- **Colors:** ${colorCount} defined (${colorSample}${colorCount > 3 ? ', ...' : ''})`);
  }

  if (theme.typography) {
    summaryLines.push('- **Typography:** Configured');
  }

  if (theme.shapes) {
    summaryLines.push('- **Shapes:** Configured');
  }

  if (summaryLines.length === 2) {
    summaryLines.push('Theme loaded (no detailed configuration).');
  }

  summaryLines.push('');
  return summaryLines.join('\n');
}

/**
 * Generates the Editing Instructions section.
 * AC-23.1.9: Tells Claude Code how to modify plan.yaml.
 */
function generateEditingInstructions(): string {
  return [
    '## Editing Instructions',
    '',
    'To edit this deck, modify `plan.yaml` directly. The Plan Editor will automatically sync your changes in real-time.',
    '',
    '### YAML Field Reference',
    '',
    '| Field | Description |',
    '|---|---|',
    '| `description` | Short one-line title/explainer for the slide (required) |',
    '| `suggested_template` | Template name from the catalog |',
    '| `key_points` | Array of talking points (required, min 1) |',
    '| `design_plan` | Visual guidance for the slide |',
    '| `tone` | Tone of voice (e.g., "professional", "casual") |',
    '| `storyline_role` | Narrative function: hook, context, evidence, detail, transition, cta |',
    '| `agenda_section_id` | Section this slide belongs to |',
    '| `status` | Build status: pending or built |',
    '',
    '### Slide Numbering Rules',
    '',
    '- Slide numbers are 1-indexed and must be sequential',
    '- When adding slides, insert into the `slides` array and renumber all subsequent slides',
    '- When deleting slides, remove from array and renumber',
    '- The Plan Editor will auto-renumber if you add/delete via the UI',
    '',
    '### Array Structure',
    '',
    '```yaml',
    'slides:',
    '  - number: 1',
    '    description: "Opening slide"',
    '    suggested_template: "title-slide"',
    '    key_points:',
    '      - "First point"',
    '      - "Second point"',
    '    # ... other fields',
    '```',
    '',
  ].join('\n');
}

/**
 * Generates the Focused Slide section (only when "Edit with Claude" is clicked).
 * This provides detailed context about the selected slide for AI-assisted editing.
 */
function generateFocusedSlideSection(
  slide: SlideEntry,
  neighbors: { previous?: SlideEntry; next?: SlideEntry } | undefined,
  plan: PlanData
): string {
  const description = getSlideIntent(slide);
  const template = getSlideTemplate(slide);
  const visualGuidance = getSlideVisualGuidance(slide);
  const keyPoints = slide.key_points || [];

  // Find section title
  const sections = getAgendaSections(plan);
  const section = sections.find(s => s.id === slide.agenda_section_id);
  const sectionTitle = section?.title || slide.agenda_section_id || '';

  const lines: string[] = [
    '## Currently Focused Slide',
    '',
    'The user has selected this slide for AI-assisted editing:',
    '',
    `- **Slide Number:** ${slide.number}`,
    `- **Description:** ${description}`,
    `- **Template:** ${template}`,
    `- **Key Points:**`,
  ];

  if (keyPoints.length > 0) {
    keyPoints.forEach(point => {
      lines.push(`  - ${point}`);
    });
  } else {
    lines.push('  - (none)');
  }

  lines.push(
    `- **Visual Guidance:** ${visualGuidance}`,
    `- **Tone:** ${slide.tone || ''}`,
    `- **Storyline Role:** ${slide.storyline_role || ''}`,
    `- **Section:** ${slide.agenda_section_id || ''} — ${sectionTitle}`,
    ''
  );

  // Neighboring slides
  lines.push('### Neighboring Slides', '');
  if (neighbors?.previous) {
    const prevDesc = getSlideIntent(neighbors.previous);
    lines.push(`- **Previous:** Slide ${neighbors.previous.number}: ${prevDesc}`);
  } else {
    lines.push('- **Previous:** (none - this is the first slide)');
  }
  if (neighbors?.next) {
    const nextDesc = getSlideIntent(neighbors.next);
    lines.push(`- **Next:** Slide ${neighbors.next.number}: ${nextDesc}`);
  } else {
    lines.push('- **Next:** (none - this is the last slide)');
  }
  lines.push('');

  // Suggested actions
  lines.push(
    '### Suggested Actions',
    '',
    '- Modify this slide\'s description or key points',
    '- Change the template assignment',
    '- Add related slides before or after this one',
    '- Adjust the tone or visual guidance',
    ''
  );

  return lines.join('\n');
}

/**
 * Generates the Recommended Workflows for Plan Editing section.
 * AC-3: Included when no focused slide (plan-level context).
 * AC-4: Contains decision guide table with plan-deck, plan-one, add-slide, edit, and direct YAML.
 * AC-5: Mutually exclusive with focused slide section.
 */
function generatePlanEditingWorkflows(): string {
  return [
    '## Recommended Workflows for Plan Editing',
    '',
    'The user opened Claude from the plan-level view. Use the appropriate workflow based on their request:',
    '',
    '| Workflow | Command | When to Use |',
    '|---------|---------|-------------|',
    '| **Edit Plan** | `/sb-create:edit-plan` | Apply a targeted edit to plan.yaml: change narrative, modify fields, add/remove slides |',
    '| **Plan Deck** | `/sb-create:plan-deck` | Full deck restructure: replan sections, reorder slides, change audience/purpose |',
    '| **Plan One** | `/sb-create:plan-one` | Plan a single new slide with full content capture and template matching |',
    '| **Add Slide** | `/sb-create:add-slide` | Quick-add a slide to an existing section |',
    '| **Edit Slide** | `/sb-create:edit` | Edit the layout/design of a built slide |',
    '',
    '### Decision Guide',
    '',
    '- User wants to **make a targeted plan change** → `/sb-create:edit-plan` (automatic from Edit with Claude)',
    '- User wants to **completely restructure the deck** → `/sb-create:plan-deck`',
    '- User wants to **add a single slide** → `/sb-create:plan-one` or `/sb-create:add-slide`',
    '- User wants to **redesign a built slide** → `/sb-create:edit`',
    '',
  ].join('\n');
}

// =============================================================================
// File I/O Functions
// =============================================================================

/**
 * Writes the context file to .slide-builder/plan-editor-context.md.
 * Creates the .slide-builder/ directory if it doesn't exist.
 *
 * AC-23.1.1: Context file written on activation.
 * AC-23.1.15: Directory created if missing.
 * AC-23.1.16: Errors logged, not surfaced to user.
 *
 * @param workspaceFolder - The workspace root URI
 * @param content - The markdown content to write
 * @param outputChannel - Optional output channel for logging
 */
export async function writeContextFile(
  workspaceFolder: vscode.Uri,
  content: string,
  outputChannel?: vscode.OutputChannel
): Promise<void> {
  try {
    const dirUri = vscode.Uri.joinPath(workspaceFolder, CONTEXT_DIR);
    const fileUri = vscode.Uri.joinPath(dirUri, CONTEXT_FILENAME);

    // AC-23.1.15: Create directory if it doesn't exist
    try {
      await vscode.workspace.fs.createDirectory(dirUri);
    } catch {
      // Directory may already exist, ignore error
    }

    // Write context file
    const contentBytes = new TextEncoder().encode(content);
    await vscode.workspace.fs.writeFile(fileUri, contentBytes);

    outputChannel?.appendLine(`[Claude Context] Written context file: ${fileUri.fsPath}`);
  } catch (error) {
    // AC-23.1.16: Log error, don't surface to user (context is supplementary)
    outputChannel?.appendLine(`[Claude Context] Failed to write context file: ${error}`);
  }
}

/**
 * Deletes the context file from .slide-builder/plan-editor-context.md.
 * Does not error if the file doesn't exist.
 *
 * AC-23.1.13: Context file deleted on panel dispose.
 * AC-23.1.16: Errors logged, not surfaced to user.
 *
 * @param workspaceFolder - The workspace root URI
 * @param outputChannel - Optional output channel for logging
 */
export async function deleteContextFile(
  workspaceFolder: vscode.Uri,
  outputChannel?: vscode.OutputChannel
): Promise<void> {
  try {
    const fileUri = vscode.Uri.joinPath(workspaceFolder, CONTEXT_DIR, CONTEXT_FILENAME);

    try {
      await vscode.workspace.fs.delete(fileUri);
      outputChannel?.appendLine(`[Claude Context] Deleted context file`);
    } catch {
      // File may not exist, ignore error
      outputChannel?.appendLine(`[Claude Context] Context file not found (nothing to delete)`);
    }
  } catch (error) {
    // AC-23.1.16: Log error, don't surface to user
    outputChannel?.appendLine(`[Claude Context] Failed to delete context file: ${error}`);
  }
}

// =============================================================================
// Utility Functions
// =============================================================================

/**
 * Escapes special characters in table cells to prevent markdown formatting issues.
 * Handles pipe characters and newlines.
 */
function escapeTableCell(value: string): string {
  if (!value) return '';
  return value
    .replace(/\|/g, '\\|')
    .replace(/\n/g, ' ')
    .replace(/\r/g, '');
}
