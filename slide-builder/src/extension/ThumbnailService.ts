import * as vscode from 'vscode';
import * as crypto from 'crypto';
import type { DeckInfo, ThumbnailCacheEntry, ThumbnailCacheIndex } from '../shared/types';

/**
 * ThumbnailService - Generates, caches, and manages deck thumbnails.
 *
 * Story Reference: cv-5-3 AC-18 through AC-26
 * Architecture Reference: ADR-006 — Webview-based thumbnail generation (no Playwright)
 *
 * AC-18: Skeleton shimmer placeholders while thumbnails generate in background
 * AC-19: Thumbnails generated by rendering slide HTML in hidden WebviewPanel + html2canvas (640x360 PNG)
 * AC-20: Cache at .slide-builder/cache/thumbnails/ with md5(filePath + mtime) keys
 * AC-21: Lazy loading via IntersectionObserver (handled in webview hook)
 * AC-22: Background pre-generation after initial load
 * AC-23: Fallback placeholder on generation failure
 * AC-24: Cache eviction for orphaned thumbnails on startup
 * AC-25: Generation completes within 2 seconds per deck (NFR3)
 * AC-26: Cache index at .slide-builder/cache/thumbnails/index.json
 */
export class ThumbnailService implements vscode.Disposable {
  private readonly cacheDir: vscode.Uri;
  private readonly indexPath: vscode.Uri;
  private cacheIndex: ThumbnailCacheIndex = { version: 1, entries: [] };
  private generationQueue: Array<{ sourcePath: string; cacheKey: string; resolve: (uri: string | undefined) => void }> = [];
  private isProcessingQueue = false;
  private activePanel: vscode.WebviewPanel | undefined;
  private disposed = false;

  constructor(
    private readonly extensionUri: vscode.Uri,
    private readonly workspaceRoot: vscode.Uri,
    private readonly outputChannel: vscode.OutputChannel
  ) {
    this.cacheDir = vscode.Uri.joinPath(workspaceRoot, '.slide-builder', 'cache', 'thumbnails');
    this.indexPath = vscode.Uri.joinPath(this.cacheDir, 'index.json');
  }

  /**
   * Initializes the service by loading the cache index.
   * Call this during extension activation.
   */
  async initialize(): Promise<void> {
    await this.ensureCacheDirectory();
    await this.loadCacheIndex();
    this.outputChannel.appendLine(`ThumbnailService: Initialized with ${this.cacheIndex.entries.length} cached thumbnails`);
  }

  /**
   * Gets a thumbnail URI for the given slide HTML source path.
   * Returns cached thumbnail if available, otherwise generates a new one.
   *
   * @param sourcePath - Absolute path to the slide HTML file
   * @param webview - The webview to convert URIs for (optional, for returning webview-safe URIs)
   * @returns Webview-safe URI string or undefined if generation fails
   */
  async getThumbnail(sourcePath: string, webview?: vscode.Webview): Promise<string | undefined> {
    try {
      // Get file mtime for cache key
      const stat = await vscode.workspace.fs.stat(vscode.Uri.file(sourcePath));
      const mtime = stat.mtime;
      const cacheKey = this.generateCacheKey(sourcePath, mtime);

      // Check cache first
      const cached = this.getCachedThumbnail(cacheKey, webview);
      if (cached) {
        this.outputChannel.appendLine(`ThumbnailService: Cache HIT for ${sourcePath}`);
        return cached;
      }

      this.outputChannel.appendLine(`ThumbnailService: Cache MISS for ${sourcePath} — queuing generation`);

      // Queue for generation
      return this.queueGeneration(sourcePath, cacheKey, webview);
    } catch (error) {
      this.outputChannel.appendLine(`ThumbnailService: Error getting thumbnail for ${sourcePath}: ${error}`);
      return undefined;
    }
  }

  /**
   * Generates an MD5 cache key from file path and modification time.
   * AC-20: md5(filePath + mtime) ensures automatic invalidation when slides change.
   */
  private generateCacheKey(sourcePath: string, mtime: number): string {
    const hash = crypto.createHash('md5');
    hash.update(sourcePath + mtime.toString());
    return hash.digest('hex');
  }

  /**
   * Checks cache for an existing thumbnail.
   * Returns webview-safe URI if found and file exists.
   */
  private getCachedThumbnail(cacheKey: string, webview?: vscode.Webview): string | undefined {
    const entry = this.cacheIndex.entries.find(e => e.cacheKey === cacheKey);
    if (!entry) {
      return undefined;
    }

    // Verify file exists
    const thumbnailUri = vscode.Uri.file(entry.thumbnailPath);
    try {
      // Note: We can't do async stat here, but we'll trust the index.
      // If file is missing, it'll be caught when loading the image.
      if (webview) {
        return webview.asWebviewUri(thumbnailUri).toString();
      }
      return thumbnailUri.fsPath;
    } catch {
      return undefined;
    }
  }

  /**
   * Queues a thumbnail generation request.
   * Sequential queue prevents resource contention (AC-25).
   */
  private queueGeneration(sourcePath: string, cacheKey: string, webview?: vscode.Webview): Promise<string | undefined> {
    return new Promise((resolve) => {
      this.generationQueue.push({
        sourcePath,
        cacheKey,
        resolve: (uri) => {
          if (uri && webview) {
            resolve(webview.asWebviewUri(vscode.Uri.file(uri)).toString());
          } else {
            resolve(uri);
          }
        }
      });
      this.processQueue();
    });
  }

  /**
   * Processes the generation queue sequentially.
   * One thumbnail at a time to avoid resource contention.
   */
  private async processQueue(): Promise<void> {
    if (this.isProcessingQueue || this.generationQueue.length === 0 || this.disposed) {
      return;
    }

    this.isProcessingQueue = true;

    while (this.generationQueue.length > 0 && !this.disposed) {
      const item = this.generationQueue.shift()!;

      try {
        const thumbnailPath = await this.generateThumbnail(item.sourcePath, item.cacheKey);
        item.resolve(thumbnailPath);
      } catch (error) {
        this.outputChannel.appendLine(`ThumbnailService: Generation failed for ${item.sourcePath}: ${error}`);
        item.resolve(undefined);
      }
    }

    this.isProcessingQueue = false;
  }

  /**
   * Generates a thumbnail using a hidden WebviewPanel + html2canvas.
   * AC-19: Renders slide HTML, captures at 640x360 PNG.
   */
  private async generateThumbnail(sourcePath: string, cacheKey: string): Promise<string | undefined> {
    const startTime = Date.now();

    try {
      // Read the slide HTML
      const sourceUri = vscode.Uri.file(sourcePath);
      const htmlContent = await vscode.workspace.fs.readFile(sourceUri);
      const htmlString = Buffer.from(htmlContent).toString('utf-8');

      // Create hidden webview panel
      const panel = vscode.window.createWebviewPanel(
        'thumbnailCapture',
        'Thumbnail Capture',
        { viewColumn: vscode.ViewColumn.Beside, preserveFocus: true },
        {
          enableScripts: true,
          localResourceRoots: [
            this.workspaceRoot,
            vscode.Uri.joinPath(this.extensionUri, 'dist'),
            vscode.Uri.joinPath(this.extensionUri, 'node_modules')
          ]
        }
      );

      // Hide the panel by immediately revealing it in background
      // Note: VS Code doesn't have a true "hidden" panel, but we can minimize impact
      this.activePanel = panel;

      // Generate thumbnail using html2canvas in webview
      const thumbnailData = await this.captureWithHtml2Canvas(panel, htmlString, sourceUri);

      // Dispose panel
      panel.dispose();
      this.activePanel = undefined;

      if (!thumbnailData) {
        return undefined;
      }

      // Save thumbnail to cache
      const thumbnailPath = await this.saveThumbnail(cacheKey, thumbnailData, sourcePath);

      const elapsed = Date.now() - startTime;
      this.outputChannel.appendLine(`ThumbnailService: Generated thumbnail for ${sourcePath} in ${elapsed}ms`);

      return thumbnailPath;
    } catch (error) {
      this.outputChannel.appendLine(`ThumbnailService: Error generating thumbnail: ${error}`);
      this.activePanel?.dispose();
      this.activePanel = undefined;
      return undefined;
    }
  }

  /**
   * Captures thumbnail using html2canvas in a webview.
   * Returns base64 PNG data.
   */
  private captureWithHtml2Canvas(
    panel: vscode.WebviewPanel,
    htmlString: string,
    sourceUri: vscode.Uri
  ): Promise<string | undefined> {
    return new Promise((resolve) => {
      const timeout = setTimeout(() => {
        this.outputChannel.appendLine('ThumbnailService: Capture timeout');
        resolve(undefined);
      }, 5000); // 5 second timeout

      // Listen for capture result
      const disposable = panel.webview.onDidReceiveMessage((message) => {
        if (message.type === 'capture-complete') {
          clearTimeout(timeout);
          disposable.dispose();
          resolve(message.data);
        } else if (message.type === 'capture-error') {
          clearTimeout(timeout);
          disposable.dispose();
          this.outputChannel.appendLine(`ThumbnailService: Capture error: ${message.error}`);
          resolve(undefined);
        }
      });

      // Get the base directory for relative resource paths
      const baseDir = vscode.Uri.joinPath(sourceUri, '..');
      const baseDirWebviewUri = panel.webview.asWebviewUri(baseDir);

      // Inject html2canvas and capture script
      const captureScript = `
        <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
        <script>
          const vscode = acquireVsCodeApi();

          // Wait for content to load
          window.addEventListener('load', async () => {
            try {
              // Give time for images and fonts to load
              await new Promise(r => setTimeout(r, 500));

              // Capture the full document at the specified viewport size
              const fullCanvas = await html2canvas(document.body, {
                windowWidth: 1920,
                windowHeight: 1080,
                width: 1920,
                height: 1080,
                scale: 1,
                useCORS: true,
                allowTaint: true,
                logging: false,
                x: 0,
                y: 0
              });

              // Scale down to 640x360 thumbnail (16:9 aspect ratio)
              const thumbCanvas = document.createElement('canvas');
              thumbCanvas.width = 640;
              thumbCanvas.height = 360;
              const ctx = thumbCanvas.getContext('2d');

              // Draw the full canvas scaled to fit the thumbnail dimensions
              ctx.drawImage(
                fullCanvas,
                0, 0, fullCanvas.width, fullCanvas.height,  // source rect (full canvas)
                0, 0, 640, 360                               // dest rect (thumbnail)
              );

              const dataUrl = thumbCanvas.toDataURL('image/png');
              vscode.postMessage({ type: 'capture-complete', data: dataUrl });
            } catch (error) {
              vscode.postMessage({ type: 'capture-error', error: error.message });
            }
          });
        </script>
      `;

      // Inject base tag for relative paths and add capture script
      let modifiedHtml = htmlString;

      // Add base tag for relative resources
      if (!modifiedHtml.includes('<base')) {
        modifiedHtml = modifiedHtml.replace('<head>', `<head><base href="${baseDirWebviewUri}/">`);
      }

      // Add capture script before closing body tag
      modifiedHtml = modifiedHtml.replace('</body>', `${captureScript}</body>`);

      panel.webview.html = modifiedHtml;
    });
  }

  /**
   * Saves thumbnail to cache directory and updates index.
   */
  private async saveThumbnail(cacheKey: string, dataUrl: string, sourcePath: string): Promise<string> {
    // Extract base64 data
    const base64Data = dataUrl.replace(/^data:image\/png;base64,/, '');
    const buffer = Buffer.from(base64Data, 'base64');

    // Save PNG file
    const thumbnailPath = vscode.Uri.joinPath(this.cacheDir, `${cacheKey}.png`);
    await vscode.workspace.fs.writeFile(thumbnailPath, buffer);

    // Update cache index
    const entry: ThumbnailCacheEntry = {
      sourcePath,
      cacheKey,
      thumbnailPath: thumbnailPath.fsPath,
      generatedAt: Date.now()
    };

    // Remove any existing entry for this source
    this.cacheIndex.entries = this.cacheIndex.entries.filter(e => e.sourcePath !== sourcePath);
    this.cacheIndex.entries.push(entry);

    await this.saveCacheIndex();

    return thumbnailPath.fsPath;
  }

  /**
   * Evicts orphaned cache entries where source files no longer exist.
   * AC-24: Called on extension activation (startup).
   */
  async evictOrphanedEntries(): Promise<void> {
    const toRemove: ThumbnailCacheEntry[] = [];

    for (const entry of this.cacheIndex.entries) {
      try {
        await vscode.workspace.fs.stat(vscode.Uri.file(entry.sourcePath));
      } catch {
        // Source file doesn't exist
        toRemove.push(entry);
      }
    }

    if (toRemove.length === 0) {
      this.outputChannel.appendLine('ThumbnailService: No orphaned cache entries to evict');
      return;
    }

    // Remove orphaned entries and delete PNG files
    for (const entry of toRemove) {
      try {
        await vscode.workspace.fs.delete(vscode.Uri.file(entry.thumbnailPath));
      } catch {
        // File may already be gone
      }
    }

    this.cacheIndex.entries = this.cacheIndex.entries.filter(
      e => !toRemove.some(r => r.cacheKey === e.cacheKey)
    );

    await this.saveCacheIndex();

    this.outputChannel.appendLine(`ThumbnailService: Evicted ${toRemove.length} orphaned cache entries`);
  }

  /**
   * Pre-generates thumbnails for all decks in the background.
   * AC-22: After initial load, remaining thumbnails pre-generate.
   */
  async preGenerateAll(decks: DeckInfo[], webview?: vscode.Webview): Promise<void> {
    this.outputChannel.appendLine(`ThumbnailService: Pre-generating thumbnails for ${decks.length} decks`);

    for (const deck of decks) {
      if (this.disposed) {
        break;
      }

      // Skip decks without built slides
      if (deck.builtSlideCount === 0) {
        continue;
      }

      try {
        // Find first slide HTML
        const slidesDir = vscode.Uri.joinPath(
          this.workspaceRoot,
          '.slide-builder',
          'output',
          deck.id,
          'slides'
        );

        const files = await vscode.workspace.fs.readDirectory(slidesDir);
        const htmlFiles = files
          .filter(([name, type]) => type === vscode.FileType.File && name.endsWith('.html') && !name.includes('.vscode-viewer'))
          .sort(([a], [b]) => a.localeCompare(b));

        if (htmlFiles.length > 0) {
          const firstSlide = vscode.Uri.joinPath(slidesDir, htmlFiles[0][0]);
          await this.getThumbnail(firstSlide.fsPath, webview);
        }
      } catch (error) {
        this.outputChannel.appendLine(`ThumbnailService: Error pre-generating for deck ${deck.id}: ${error}`);
      }
    }

    this.outputChannel.appendLine('ThumbnailService: Pre-generation complete');
  }

  /**
   * Generates a placeholder image data URL for failed thumbnails.
   * AC-23: Colored rectangle with deck initials or "Slide N".
   */
  generatePlaceholder(label: string): string {
    // Return a data URL for a simple colored rectangle with text
    // Using #3a61ff background with white text
    const svg = `
      <svg xmlns="http://www.w3.org/2000/svg" width="640" height="360" viewBox="0 0 640 360">
        <rect width="100%" height="100%" fill="#3a61ff"/>
        <text x="50%" y="50%" text-anchor="middle" dy=".35em"
              fill="white" font-family="system-ui, sans-serif" font-size="48" font-weight="600">
          ${this.escapeXml(label)}
        </text>
      </svg>
    `;
    return `data:image/svg+xml;base64,${Buffer.from(svg).toString('base64')}`;
  }

  /**
   * Gets deck initials for placeholder.
   */
  getDeckInitials(deckName: string): string {
    return deckName
      .split(/\s+/)
      .slice(0, 2)
      .map(word => word.charAt(0).toUpperCase())
      .join('');
  }

  private escapeXml(text: string): string {
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&apos;');
  }

  /**
   * Ensures cache directory exists.
   */
  private async ensureCacheDirectory(): Promise<void> {
    try {
      await vscode.workspace.fs.createDirectory(this.cacheDir);
    } catch {
      // Directory may already exist
    }
  }

  /**
   * Loads cache index from disk.
   */
  private async loadCacheIndex(): Promise<void> {
    try {
      const data = await vscode.workspace.fs.readFile(this.indexPath);
      const json = Buffer.from(data).toString('utf-8');
      this.cacheIndex = JSON.parse(json);
    } catch {
      // Index doesn't exist or is corrupted - start fresh
      this.cacheIndex = { version: 1, entries: [] };
    }
  }

  /**
   * Saves cache index to disk.
   * AC-26: Cache index stored in .slide-builder/cache/thumbnails/index.json
   */
  private async saveCacheIndex(): Promise<void> {
    const json = JSON.stringify(this.cacheIndex, null, 2);
    await vscode.workspace.fs.writeFile(this.indexPath, Buffer.from(json, 'utf-8'));
  }

  /**
   * Clears the entire thumbnail cache.
   * Useful for debugging or when cache becomes corrupted.
   */
  async clearCache(): Promise<void> {
    try {
      await vscode.workspace.fs.delete(this.cacheDir, { recursive: true });
      this.cacheIndex = { version: 1, entries: [] };
      await this.ensureCacheDirectory();
      this.outputChannel.appendLine('ThumbnailService: Cache cleared');
    } catch (error) {
      this.outputChannel.appendLine(`ThumbnailService: Error clearing cache: ${error}`);
    }
  }

  dispose(): void {
    this.disposed = true;
    this.activePanel?.dispose();
    this.generationQueue = [];
    this.outputChannel.appendLine('ThumbnailService: Disposed');
  }
}
